{"code":"(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[17],{\"20a2\":function(e,r,t){e.exports=t(\"nOHt\")},\"2Bli\":function(e,r,t){\"use strict\";t.d(r,\"a\",(function(){return l}));var n=t(\"q1tI\"),s=t.n(n),c=t(\"7vrA\"),i=t(\"3Z9Z\"),u=t(\"JI6e\"),a=s.a.createElement,l=function(e){var r=e.pageTitle,t=e.children;return a(\"div\",{className:\"breadcrumb-section space-pt--r70\"},a(c.a,null,a(i.a,{className:\"align-items-center\"},a(u.a,{md:6},a(\"div\",{className:\"page-title\"},a(\"h3\",{className:\"breadcrumb-title\"},r))),a(u.a,{md:6},t))))};s.a.createElement},NKCw:function(e,r,t){\"use strict\";t.d(r,\"a\",(function(){return E})),t.d(r,\"b\",(function(){return f})),t.d(r,\"c\",(function(){return T})),t.d(r,\"d\",(function(){return ge}));var n=t(\"q1tI\"),s=e=>\"checkbox\"===e.type,c=e=>null==e;const i=e=>\"object\"===typeof e;var u=e=>!c(e)&&!Array.isArray(e)&&i(e)&&!(e instanceof Date),a=e=>e.substring(0,e.search(/.\\d/))||e,l=e=>e.filter(Boolean),o=e=>void 0===e,f=(e={},r,t)=>{const n=l(r.split(/[,[\\].]+?/)).reduce(((e,r)=>c(e)?e:e[r]),e);return o(n)||n===e?o(e[r])?t:e[r]:n};const d=\"blur\",b=\"onBlur\",y=\"onChange\",g=\"onSubmit\",m=\"onTouched\",v=\"all\",h=\"undefined\",O=\"max\",p=\"min\",j=\"maxLength\",k=\"minLength\",V=\"pattern\",w=\"required\",A=\"validate\";var _=(e,r)=>{const t=Object.assign({},e);return delete t[r],t};const x=n.createContext(null);x.displayName=\"RHFContext\";var R=(e,r,t,n,s=!0)=>e?new Proxy(r,{get:(e,r)=>{if(r in e)return t.current[r]!==v&&(t.current[r]=!s||v),n&&(n.current[r]=!0),e[r]}}):r,S=e=>u(e)&&!Object.keys(e).length,D=(e,r,t)=>S(e)||Object.keys(e).length>=Object.keys(r).length||Object.keys(e).find((e=>r[e]===(!t||v))),C=typeof window!==h&&typeof window.HTMLElement!==h&&typeof document!==h;const F=C?\"Proxy\"in window:typeof Proxy!==h;var E=(e,r,t,n,s)=>r?Object.assign(Object.assign({},t[e]),{types:Object.assign(Object.assign({},t[e]&&t[e].types?t[e].types:{}),{[n]:s||!0})}):{},N=e=>/^\\w*$/.test(e),B=e=>l(e.replace(/[\"|']|\\]/g,\"\").split(/\\.|\\[/));function T(e,r,t){let n=-1;const s=N(r)?[r]:B(r),c=s.length,i=c-1;for(;++n<c;){const r=s[n];let c=t;if(n!==i){const t=e[r];c=u(t)||Array.isArray(t)?t:isNaN(+s[n+1])?{}:[]}e[r]=c,e=e[r]}return e}const I=(e,r,t)=>{for(const n of t||Object.keys(e)){const t=f(e,n);if(t){const e=t._f,n=_(t,\"_f\");if(e&&r(e.name)){if(e.ref.focus&&o(e.ref.focus()))break;if(e.refs){e.refs[0].focus();break}}else u(n)&&I(n,r)}}},M=(e,r={current:{}},t={})=>{for(const n in e.current){const s=e.current[n];if(s){const e=s._f,c=_(s,\"_f\");T(t,n,e?e.ref.disabled||e.refs&&e.refs.every((e=>e.disabled))?void 0:e.value:Array.isArray(s)?[]:{}),c&&M({current:c},r,t[n])}}return Object.assign(Object.assign({},r.current),t)};var L=e=>c(e)||!i(e);function q(e,r,t){if(L(e)||L(r)||e instanceof Date||r instanceof Date)return e===r;if(!n.isValidElement(e)){const n=Object.keys(e),s=Object.keys(r);if(n.length!==s.length)return!1;for(const c of n){const n=e[c];if(!t||\"ref\"!==c){const e=r[c];if((u(n)||Array.isArray(n))&&(u(e)||Array.isArray(e))?!q(n,e,t):n!==e)return!1}}}return!0}function H(e,r){if(L(e)||L(r))return r;for(const n in r){const s=e[n],c=r[n];try{e[n]=u(s)&&u(c)||Array.isArray(s)&&Array.isArray(c)?H(s,c):c}catch(t){}}return e}function P(e,r,t,n,s){let c=-1;for(;++c<e.length;){for(const n in e[c])Array.isArray(e[c][n])?(!t[c]&&(t[c]={}),t[c][n]=[],P(e[c][n],f(r[c]||{},n,[]),t[c][n],t[c],n)):q(f(r[c]||{},n),e[c][n])?T(t[c]||{},n):t[c]=Object.assign(Object.assign({},t[c]),{[n]:!0});n&&!t.length&&delete n[s]}return t}var J=(e,r,t)=>H(P(e,r,t.slice(0,e.length)),P(r,e,t.slice(0,e.length)));var $=e=>\"boolean\"===typeof e;function W(e,r){const t=N(r)?[r]:B(r),n=1==t.length?e:function(e,r){const t=r.slice(0,-1).length;let n=0;for(;n<t;)e=o(e)?n++:e[r[n++]];return e}(e,t),s=t[t.length-1];let c;n&&delete n[s];for(let i=0;i<t.slice(0,-1).length;i++){let r,n=-1;const s=t.slice(0,-(i+1)),a=s.length-1;for(i>0&&(c=e);++n<s.length;){const t=s[n];r=r?r[t]:e[t],a===n&&(u(r)&&S(r)||Array.isArray(r)&&!r.filter((e=>u(e)&&!S(e)||$(e))).length)&&(c?delete c[t]:delete e[t]),c=r}}return e}function Z(e,r){const t={};for(const n of e){const e=f(r,n);e&&(N(n)?t[n]=e._f:T(t,n,e._f))}return t}var K=e=>\"file\"===e.type,z=e=>\"select-multiple\"===e.type,G=e=>\"radio\"===e.type;const Q={value:!1,isValid:!1},U={value:!0,isValid:!0};var X=e=>{if(Array.isArray(e)){if(e.length>1){const r=e.filter((e=>e&&e.checked&&!e.disabled)).map((e=>e.value));return{value:r,isValid:!!r.length}}return e[0].checked&&!e[0].disabled?e[0].attributes&&!o(e[0].attributes.value)?o(e[0].value)||\"\"===e[0].value?U:{value:e[0].value,isValid:!0}:U:Q}return Q};const Y={isValid:!1,value:null};var ee=e=>Array.isArray(e)?e.reduce(((e,r)=>r&&r.checked&&!r.disabled?{isValid:!0,value:r.value}:e),Y):Y;function re(e){if(e&&e._f){const t=e._f.ref;if(t.disabled)return;return K(t)?t.files:G(t)?ee(e._f.refs).value:z(t)?(r=t.options,[...r].filter((({selected:e})=>e)).map((({value:e})=>e))):s(t)?X(e._f.refs).value:((e,{valueAsNumber:r,valueAsDate:t,setValueAs:n})=>r?\"\"===e?NaN:+e:t?new Date(e):n?n(e):e)(o(t.value)?e._f.ref.value:t.value,e._f)}var r}var te=e=>\"function\"===typeof e,ne=e=>\"string\"===typeof e,se=e=>ne(e)||n.isValidElement(e),ce=e=>e instanceof RegExp;function ie(e,r,t=\"validate\"){if(se(e)||$(e)&&!e)return{type:t,message:se(e)?e:\"\",ref:r}}var ue=e=>u(e)&&!ce(e)?e:{value:e,message:\"\"},ae=async({_f:{ref:e,refs:r,required:t,maxLength:n,minLength:i,min:a,max:l,pattern:o,validate:f,name:d,value:b,valueAsNumber:y}},g)=>{const m={},v=G(e),h=s(e),_=v||h,x=(y||K(e))&&!e.value||\"\"===b||Array.isArray(b)&&!b.length,R=E.bind(null,d,g,m),D=(r,t,n,s=j,c=k)=>{const i=r?t:n;m[d]=Object.assign({type:r?s:c,message:i,ref:e},R(r?s:c,i))};if(t&&(!v&&!h&&(x||c(b))||$(b)&&!b||h&&!X(r).isValid||v&&!ee(r).isValid)){const{value:n,message:s}=se(t)?{value:!!t,message:t}:ue(t);if(n&&(m[d]=Object.assign({type:w,message:s,ref:_?(r||[])[0]||{}:e},R(w,s)),!g))return m}if((!c(a)||!c(l))&&\"\"!==b){let r,t;const n=ue(l),s=ue(a);if(isNaN(b)){const c=e.valueAsDate||new Date(b);ne(n.value)&&(r=c>new Date(n.value)),ne(s.value)&&(t=c<new Date(s.value))}else{const i=e.valueAsNumber||parseFloat(b);c(n.value)||(r=i>n.value),c(s.value)||(t=i<s.value)}if((r||t)&&(D(!!r,n.message,s.message,O,p),!g))return m}if(ne(b)&&!x&&(n||i)){const e=ue(n),r=ue(i),t=!c(e.value)&&b.length>e.value,s=!c(r.value)&&b.length<r.value;if((t||s)&&(D(t,e.message,r.message),!g))return m}if(ne(b)&&o&&!x){const{value:r,message:t}=ue(o);if(ce(r)&&!b.match(r)&&(m[d]=Object.assign({type:V,message:t,ref:e},R(V,t)),!g))return m}if(f){const t=_&&r?r[0]:e;if(te(f)){const e=ie(await f(b),t);if(e&&(m[d]=Object.assign(Object.assign({},e),R(A,e.message)),!g))return m}else if(u(f)){let e={};for(const[r,n]of Object.entries(f)){if(!S(e)&&!g)break;const s=ie(await n(b),t,r);s&&(e=Object.assign(Object.assign({},s),R(r,s.message)),g&&(m[d]=e))}if(!S(e)&&(m[d]=Object.assign({ref:t},e),!g))return m}}return m},le=e=>({isOnSubmit:!e||e===g,isOnBlur:e===b,isOnChange:e===y,isOnAll:e===v,isOnTouch:e===m}),oe=e=>e instanceof HTMLElement;class fe{constructor(){this.tearDowns=[]}add(e){this.tearDowns.push(e)}unsubscribe(){for(const e of this.tearDowns)e();this.tearDowns=[]}}class de{constructor(e,r){this.observer=e,this.closed=!1,r.add((()=>this.closed=!0))}next(e){this.closed||this.observer.next(e)}}class be{constructor(){this.observers=[]}next(e){for(const r of this.observers)r.next(e)}subscribe(e){const r=new fe,t=new de(e,r);return this.observers.push(t),r}unsubscribe(){this.observers=[]}}const ye=typeof window===h;function ge({mode:e=g,reValidateMode:r=y,resolver:t,context:i,defaultValues:u={},shouldFocusError:b=!0,criteriaMode:m}={}){const h=n.useRef({}),O=n.useRef(new Set),p=n.useRef(new be),j=n.useRef(new be),k=n.useRef(new be),V=n.useRef(new be),w=n.useRef({}),A=n.useRef(new Set),x=n.useRef(!1),E=n.useRef({}),N=n.useRef({}),B=n.useRef(u),L=n.useRef(!1),H=n.useRef(i),P=n.useRef(t),$=n.useRef(new Set),Q=le(e),U=m===v,[X,Y]=n.useState({isDirty:!1,isValidating:!1,dirtyFields:{},isSubmitted:!1,submitCount:0,touchedFields:{},isSubmitting:!1,isSubmitSuccessful:!1,isValid:!Q.isOnSubmit,errors:{}}),ee=n.useRef({isDirty:!F,dirtyFields:!F,touchedFields:!F,isValidating:!F,isValid:!F,errors:!F}),se=n.useRef(X);H.current=i,P.current=t;const ce=()=>se.current.isValid=q(N.current,E.current)&&S(se.current.errors),ie=n.useCallback(((e,r,t=!1,n={},s,i)=>{const u=f(se.current.errors,e);let a=t||!q(u,r,!0)||ee.current.isValid&&o(r)&&f(E.current,e)&&!f(N.current,e);if(r?(W(N.current,e),a=a||!u||!q(u,r,!0),T(se.current.errors,e,r)):((f(E.current,e)||P.current)&&(T(N.current,e,!0),a=a||u),W(se.current.errors,e)),a&&!c(t)||!S(n)||i){const e=Object.assign(Object.assign({},n),{isValid:P.current?!!s:ce(),errors:se.current.errors});se.current=Object.assign(Object.assign({},se.current),e),p.current.next(i?{}:e)}p.current.next({isValidating:!1})}),[]),ue=n.useCallback(((e,r,t={},n,i)=>{i&&xe(e);const u=f(h.current,e,{})._f;if(u){const i=C&&oe(u.ref)&&c(r)?\"\":r;if(u.value=r,G(u.ref)?(u.refs||[]).forEach((e=>e.checked=e.value===i)):K(u.ref)&&!ne(i)?u.ref.files=i:z(u.ref)?[...u.ref.options].forEach((e=>e.selected=i.includes(e.value))):s(u.ref)&&u.refs?u.refs.length>1?u.refs.forEach((e=>e.checked=Array.isArray(i)?!!i.find((r=>r===e.value)):i===e.value)):u.refs[0].checked=!!i:u.ref.value=i,n){const t=M(h);T(t,e,r),k.current.next({values:Object.assign(Object.assign({},B.current),t),name:e})}t.shouldDirty&&de(e,i),t.shouldValidate&&he(e)}}),[]),fe=n.useCallback(((e,r)=>{if(ee.current.isDirty){const t=M(h);return e&&r&&T(t,e,r),!q(t,B.current)}return!1}),[]),de=n.useCallback(((e,r,t=!0)=>{if(ee.current.isDirty||ee.current.dirtyFields){const n=!q(f(B.current,e),r),s=f(se.current.dirtyFields,e),c=se.current.isDirty;n?T(se.current.dirtyFields,e,!0):W(se.current.dirtyFields,e),se.current.isDirty=fe();const i={isDirty:se.current.isDirty,dirtyFields:se.current.dirtyFields},u=ee.current.isDirty&&c!==i.isDirty||ee.current.dirtyFields&&s!==f(se.current.dirtyFields,e);return u&&t&&p.current.next(i),u?i:{}}return{}}),[]),ge=n.useCallback((async(e,r)=>{const t=(await ae(f(h.current,e),U))[e];return ie(e,t,r),o(t)}),[U]),me=n.useCallback((async(e,r=[])=>{const{errors:t}=await P.current(M(h,B),H.current,{criteriaMode:m,names:r,fields:Z(O.current,h.current)});for(const n of e){const e=f(t,n);e?T(se.current.errors,n,e):W(se.current.errors,n)}return t}),[m]),ve=async e=>{for(const r in e){const t=e[r];if(t){const e=t._f,r=_(t,\"_f\");if(e){const r=await ae(t,U);r[e.name]?(T(se.current.errors,e.name,r[e.name]),W(N.current,e.name)):f(E.current,e.name)&&(T(N.current,e.name,!0),W(se.current.errors,e.name))}r&&await ve(r)}}},he=n.useCallback((async e=>{const r=o(e)?Object.keys(h.current):Array.isArray(e)?e:[e];let t;p.current.next({isValidating:!0}),P.current?t=S(await me(r,o(e)?void 0:r)):o(e)?await ve(h.current):await Promise.all(r.map((async e=>await ge(e,null)))),p.current.next({errors:se.current.errors,isValidating:!1,isValid:P.current?t:ce()})}),[me,ge]),Oe=n.useCallback(((e,r,t)=>Object.entries(r).forEach((([r,n])=>{const s=`${e}.${r}`,c=f(h.current,s);c&&!c._f?Oe(s,n,t):ue(s,n,t,!0,!c)}))),[he]),pe=e=>L.current||A.current.has(e)||A.current.has((e.match(/\\w+/)||[])[0]),je=(e,r,t)=>{let n;const s=f(h.current,e),i=f(B.current,e);return!s||S(B.current)&&o(s._f.value)||(n=o(s._f.value)?i:s._f.value,c(n)||ue(e,n)),(i||!i&&t)&&r&&!Q.isOnSubmit&&s&&ee.current.isValid&&ae(s,U).then((r=>{S(r)?T(N.current,e,!0):W(N.current,e),se.current.isValid&&!S(r)&&Y(Object.assign(Object.assign({},se.current),{isValid:ce()}))})),n},ke=n.useCallback((async({type:e,target:t,target:{value:n,type:c}})=>{let i,u,l=t.name;const b=f(h.current,l);if(b){let y=c?re(b):void 0;y=o(y)?n:y;const g=e===d,{isOnBlur:v,isOnChange:O}=le(r),k=(({isOnBlur:e,isOnChange:r,isOnTouch:t,isTouched:n,isReValidateOnBlur:s,isReValidateOnChange:c,isBlurEvent:i,isSubmitted:u,isOnAll:a})=>!a&&(!u&&t?!(n||i):(u?s:e)?!i:!(u?c:r)||i))(Object.assign({isBlurEvent:g,isTouched:!!f(se.current.touchedFields,l),isSubmitted:se.current.isSubmitted,isReValidateOnBlur:v,isReValidateOnChange:O},Q)),V=!g&&pe(l);o(y)||(b._f.value=y);const w=de(l,b._f.value,!1);g&&!f(se.current.touchedFields,l)&&(T(se.current.touchedFields,l,!0),ee.current.touchedFields&&(w.touchedFields=se.current.touchedFields));let A=!S(w)||V;if(k)return!g&&j.current.next({name:l,type:e,value:y}),A&&p.current.next(V?{}:w);if(p.current.next({isValidating:!0}),P.current){const{errors:e}=await P.current(M(h,B),H.current,{criteriaMode:m,fields:Z([l],h.current),names:[l]}),r=se.current.isValid;if(i=f(e,l),s(t)&&!i){const r=a(l),t=f(e,r,{});t.type&&t.message&&(i=t),(t||f(se.current.errors,r))&&(l=r)}u=S(e),r!==u&&(A=!0)}else i=(await ae(b,U))[l];!g&&j.current.next({name:l,type:e,value:y}),ie(l,i,A,w,u,V)}}),[]),Ve=e=>{const r=x.current?M(h,B):B.current;return o(e)?r:ne(e)?f(r,e):e.map((e=>f(r,e)))},we=n.useCallback((async(e={})=>{const r=se.current.isValid;if(t){const{errors:r}=await P.current(Object.assign(Object.assign({},M(h,B)),e),H.current,{criteriaMode:m,fields:Z(O.current,h.current)});se.current.isValid=S(r)}else ce();r!==se.current.isValid&&p.current.next({isValid:se.current.isValid})}),[m]),Ae=n.useCallback(((e,r,t)=>{const n=Array.isArray(e),s=x.current?Ve():o(r)?B.current:n?r||{}:{[e]:r};if(o(e))return t&&(L.current=!0),s;const c=[];for(const i of n?e:[e])t&&A.current.add(i),c.push(f(s,i));return n?c:c[0]}),[]),_e=(e,r,t)=>{let n=f(h.current,e);if(n){const c=(e=>G(e)||s(e))(r);if(r===n._f.ref||C&&oe(n._f.ref)&&!oe(r)||c&&Array.isArray(n._f.refs)&&l(n._f.refs).find((e=>e===r)))return;n={_f:c?Object.assign(Object.assign({},n._f),{refs:[...l(n._f.refs||[]).filter((e=>oe(e)&&document.contains(e))),r],ref:{type:r.type,name:e}}):Object.assign(Object.assign({},n._f),{ref:r})},T(h.current,e,n);const i=je(e,t,!0);(c&&Array.isArray(i)?!q(f(h.current,e)._f.value,i):o(f(h.current,e)._f.value))&&(f(h.current,e)._f.value=re(f(h.current,e)))}},xe=n.useCallback(((e,r)=>{const t=!f(h.current,e);return T(h.current,e,{_f:Object.assign(Object.assign(Object.assign({},t?{ref:{name:e}}:Object.assign({ref:(f(h.current,e)._f||{}).ref},f(h.current,e)._f)),{name:e}),r)}),r&&T(E.current,e,!0),O.current.add(e),t&&je(e,r),ye?{name:e}:{name:e,onChange:ke,onBlur:ke,ref:t=>t&&_e(e,t,r)}}),[B.current]),Re=n.useCallback(((e,r)=>async t=>{t&&t.preventDefault&&(t.preventDefault(),t.persist());let n=Object.assign(Object.assign({},B.current),M(h,B));p.current.next({isSubmitting:!0});try{if(P.current){const{errors:e,values:r}=await P.current(n,H.current,{criteriaMode:m,fields:Z(O.current,h.current)});se.current.errors=e,n=r}else await ve(h.current);S(se.current.errors)&&Object.keys(se.current.errors).every((e=>f(n,e)))?(p.current.next({errors:{},isSubmitting:!0}),await e(n,t)):(r&&await r(se.current.errors,t),b&&I(h.current,(e=>f(se.current.errors,e)),O.current))}finally{se.current.isSubmitted=!0,p.current.next({isSubmitted:!0,isSubmitting:!1,isSubmitSuccessful:S(se.current.errors),submitCount:se.current.submitCount+1,errors:se.current.errors})}}),[b,U,m]),Se=n.useCallback((({keepErrors:e,keepDirty:r,keepIsSubmitted:t,keepTouched:n,keepIsValid:s,keepSubmitCount:c})=>{s||(N.current={},E.current={}),A.current=new Set,L.current=!1,p.current.next({submitCount:c?se.current.submitCount:0,isDirty:!!r&&se.current.isDirty,isSubmitted:!!t&&se.current.isSubmitted,isValid:s?se.current.isValid:!Q.isOnSubmit,dirtyFields:r?se.current.dirtyFields:{},touchedFields:n?se.current.touchedFields:{},errors:e?se.current.errors:{},isSubmitting:!1,isSubmitSuccessful:!1})}),[]);return n.useEffect((()=>{x.current=!0;const e=p.current.subscribe({next(e={}){D(e,ee.current,!0)&&(se.current=Object.assign(Object.assign({},se.current),e),Y(se.current))}}),r=V.current.subscribe({next(e){if(e.fields&&e.name&&ee.current.isValid){const r=M(h);T(r,e.name,e.fields),we(r)}}});return P.current&&ee.current.isValid&&we(),()=>{j.current.unsubscribe(),e.unsubscribe(),r.unsubscribe()}}),[]),{control:n.useMemo((()=>({register:xe,isWatchAllRef:L,watchFieldsRef:A,getFormIsDirty:fe,formStateSubjectRef:p,fieldArraySubjectRef:V,controllerSubjectRef:k,watchSubjectRef:j,watchInternal:Ae,fieldsRef:h,validFieldsRef:N,fieldsWithValidationRef:E,fieldArrayNamesRef:$,readFormStateRef:ee,formStateRef:se,defaultValuesRef:B,fieldArrayDefaultValuesRef:w})),[]),formState:R(F,X,ee),trigger:he,register:xe,handleSubmit:Re,watch:n.useCallback(((e,r)=>te(e)?j.current.subscribe({next:t=>e(Ae(void 0,r),t)}):Ae(e,r,!0)),[]),setValue:n.useCallback(((e,r,t={})=>{x.current=!0;const n=f(h.current,e),s=$.current.has(e);s&&(V.current.next({fields:r,name:e,isReset:!0}),(ee.current.isDirty||ee.current.dirtyFields)&&t.shouldDirty&&(T(se.current.dirtyFields,e,J(r,f(B.current,e,[]),f(se.current.dirtyFields,e,[]))),p.current.next({dirtyFields:se.current.dirtyFields,isDirty:fe(e,r)})),!r.length&&T(h.current,e,[])&&T(w.current,e,[])),n&&!n._f||s?Oe(e,r,s?{}:t):ue(e,r,t,!0,!n),pe(e)&&p.current.next({}),j.current.next({name:e,value:r})}),[Oe]),getValues:n.useCallback(Ve,[]),reset:n.useCallback(((e,r={})=>{const t=e||B.current;if(C&&!r.keepValues)for(const s of Object.values(h.current))if(s&&s._f){const e=Array.isArray(s._f.refs)?s._f.refs[0]:s._f.ref;if(oe(e))try{e.closest(\"form\").reset();break}catch(n){}}!r.keepDefaultValues&&(B.current=Object.assign({},t)),r.keepValues||(h.current={},k.current.next({values:Object.assign({},t)}),j.current.next({value:Object.assign({},t)}),V.current.next({fields:Object.assign({},t),isReset:!0})),Se(r)}),[]),clearErrors:n.useCallback((e=>{e&&(Array.isArray(e)?e:[e]).forEach((e=>W(se.current.errors,e))),p.current.next({errors:e?se.current.errors:{}})}),[]),unregister:n.useCallback(((e,r={})=>{for(const t of e?Array.isArray(e)?e:[e]:Object.keys(O.current))O.current.delete(t),$.current.delete(t),f(h.current,t)&&(r.keepIsValid||(W(E.current,t),W(N.current,t)),!r.keepError&&W(se.current.errors,t),!r.keepValue&&W(h.current,t),!r.keepDirty&&W(se.current.dirtyFields,t),!r.keepTouched&&W(se.current.touchedFields,t),!r.keepDefaultValue&&W(B.current,t),j.current.next({name:t}));p.current.next(Object.assign(Object.assign(Object.assign({},se.current),r.keepDirty?{isDirty:fe()}:{}),P.current?{}:{isValid:ce()})),r.keepIsValid||we()}),[]),setError:n.useCallback(((e,r,t)=>{const n=((f(h.current,e)||{_f:{}})._f||{}).ref;T(se.current.errors,e,Object.assign(Object.assign({},r),{ref:n})),p.current.next({errors:se.current.errors,isValid:!1}),t&&t.shouldFocus&&n&&n.focus&&n.focus()}),[])}}}}]);","map":{"version":3,"sources":["static/chunks/953b613e7867e1be5273d7b6a9f5686ba206da7b.3e824eb872f496b97828.js"],"names":["window","push","20a2","module","exports","__webpack_require__","2Bli","__webpack_exports__","d","Breadcrumb_BreadcrumbOne","react","react_default","n","Container","Row","Col","__jsx","a","createElement","_ref","pageTitle","children","className","md","NKCw","appendErrors","get","set","useForm","react__WEBPACK_IMPORTED_MODULE_0__","isCheckBoxInput","element","type","isNullOrUndefined","value","isObjectType","isObject","Array","isArray","Date","getNodeParentName","name","substring","search","compact","filter","Boolean","isUndefined","val","undefined","obj","path","defaultValue","result","split","reduce","key","EVENTS","VALIDATION_MODE","UNDEFINED","INPUT_VALIDATION_RULES","omit","source","copy","Object","assign","FormContext","displayName","getProxyFormState","isProxyEnabled","formState","readFormStateRef","localReadFormStateRef","isRoot","Proxy","prop","current","isEmptyObject","keys","length","shouldRenderFormState","find","isWeb","HTMLElement","document","validateAllFieldCriteria","errors","message","types","[object Object]","isKey","test","stringToPath","input","replace","object","index","tempPath","lastIndex","newValue","objValue","isNaN","focusFieldBy","fields","callback","fieldsNames","field","_f","ref","focus","refs","getFieldsValues","fieldsRef","defaultValuesRef","output","disabled","every","isPrimitive","deepEqual","object1","object2","isErrorObject","keys1","keys2","val1","val2","deepMerge","target","targetValue","sourceValue","_a","setDirtyFields","values","defaultValues","dirtyFields","parentNode","parentName","setFieldArrayDirtyFields","slice","isBoolean","unset","updatePath","childObject","baseGet","previousObjRef","k","objectRef","currentPaths","currentPathsLength","item","data","getFields","fieldsRefs","currentFields","isFileInput","isMultipleSelect","isRadioInput","defaultResult","isValid","validResult","getCheckboxValue","options","option","checked","map","attributes","defaultReturn","getRadioValue","previous","getFieldValue","files","selected","valueAsNumber","valueAsDate","setValueAs","NaN","getFieldValueAs","isFunction","isString","isMessage","isRegex","RegExp","getValidateError","getValueAndMessage","validationData","validateField","async","required","maxLength","minLength","min","max","pattern","validate","inputValue","error","isRadio","isCheckBox","isRadioOrCheckbox","isEmpty","appendErrorsCurry","bind","getMinMaxMessage","exceedMax","maxLengthMessage","minLengthMessage","maxType","minType","exceedMin","maxOutput","minOutput","valueDate","valueNumber","parseFloat","maxLengthOutput","minLengthOutput","patternValue","match","validateRef","validateError","validationResult","validateFunction","entries","getValidationModes","mode","isOnSubmit","isOnBlur","isOnChange","isOnAll","isOnTouch","isHTMLElement","Subscription","this","tearDowns","tearDown","teardown","Subscriber","observer","subscription","closed","add","next","Subject","observers","subscriber","isWindowUndefined","reValidateMode","resolver","context","shouldFocusError","criteriaMode","fieldsNamesRef","Set","formStateSubjectRef","watchSubjectRef","controllerSubjectRef","fieldArraySubjectRef","fieldArrayDefaultValuesRef","watchFieldsRef","isMountedRef","fieldsWithValidationRef","validFieldsRef","isWatchAllRef","contextRef","resolverRef","fieldArrayNamesRef","validationMode","isValidateAllFieldCriteria","setFormState","isDirty","isValidating","isSubmitted","submitCount","touchedFields","isSubmitting","isSubmitSuccessful","formStateRef","getIsValid","shouldRenderBaseOnError","shouldRender","state","isWatched","previousError","shouldReRender","updatedFormState","setFieldValue","rawValue","shouldRegister","register","forEach","radioRef","selectRef","includes","checkboxRef","shouldDirty","updateAndGetDirtyState","shouldValidate","trigger","getFormIsDirty","formValues","isFieldDirty","isDirtyFieldExist","previousIsDirty","isChanged","executeValidation","skipReRender","executeSchemaOrResolverValidation","names","currentNames","validateForm","fieldError","Promise","all","setInternalValues","inputKey","fieldName","isFieldWatched","has","updateValidAndValue","isWithinRefCallback","useFormDefaultValue","then","handleChange","inputType","isBlurEvent","isReValidateOnBlur","isReValidateOnChange","shouldSkipValidation","isTouched","skipValidation","previousFormIsValid","parentNodeName","currentError","getValues","fieldNames","updateIsValid","previousIsValid","watchInternal","isGlobal","isArrayNames","fieldValues","registerFieldRef","isRadioOrCheckboxFunction","contains","isInitialRegister","onChange","onBlur","handleSubmit","onValid","onInvalid","e","preventDefault","persist","resetFromState","keepErrors","keepDirty","keepIsSubmitted","keepTouched","keepIsValid","keepSubmitCount","formStateSubscription","subscribe","useFieldArraySubscription","unsubscribe","control","watch","info","setValue","isFieldArray","isReset","reset","keepStateOptions","updatedValues","keepValues","inputRef","closest","keepDefaultValues","clearErrors","inputName","unregister","delete","keepError","keepValue","keepDefaultValue","setError","shouldFocus"],"mappings":"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"},"name":"static/chunks/953b613e7867e1be5273d7b6a9f5686ba206da7b.3e824eb872f496b97828.js","input":"(window[\"webpackJsonp_N_E\"] = window[\"webpackJsonp_N_E\"] || []).push([[17],{\n\n/***/ \"20a2\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(\"nOHt\")\n\n\n/***/ }),\n\n/***/ \"2Bli\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* reexport */ Breadcrumb_BreadcrumbOne; });\n\n// UNUSED EXPORTS: ProductListBreadcrumb\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(\"q1tI\");\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Container.js\nvar Container = __webpack_require__(\"7vrA\");\n\n// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Row.js\nvar Row = __webpack_require__(\"3Z9Z\");\n\n// EXTERNAL MODULE: ./node_modules/react-bootstrap/esm/Col.js\nvar Col = __webpack_require__(\"JI6e\");\n\n// CONCATENATED MODULE: ./src/components/Breadcrumb/BreadcrumbOne.js\n\nvar __jsx = react_default.a.createElement;\n\n\nvar BreadcrumbOne_BreadcrumbOne = function BreadcrumbOne(_ref) {\n  var pageTitle = _ref.pageTitle,\n      children = _ref.children;\n  return __jsx(\"div\", {\n    className: \"breadcrumb-section space-pt--r70\"\n  }, __jsx(Container[\"a\" /* default */], null, __jsx(Row[\"a\" /* default */], {\n    className: \"align-items-center\"\n  }, __jsx(Col[\"a\" /* default */], {\n    md: 6\n  }, __jsx(\"div\", {\n    className: \"page-title\"\n  }, __jsx(\"h3\", {\n    className: \"breadcrumb-title\"\n  }, pageTitle))), __jsx(Col[\"a\" /* default */], {\n    md: 6\n  }, children))));\n};\n\n/* harmony default export */ var Breadcrumb_BreadcrumbOne = (BreadcrumbOne_BreadcrumbOne);\n// CONCATENATED MODULE: ./src/components/Breadcrumb/ProductListBreadcrumb.js\n\nvar ProductListBreadcrumb_jsx = react_default.a.createElement;\n\n\nvar ProductListBreadcrumb_BreadcrumbOne = function BreadcrumbOne(_ref) {\n  var pageTitle = _ref.pageTitle,\n      children = _ref.children;\n  return ProductListBreadcrumb_jsx(\"div\", {\n    className: \"breadcrumb-section space-pt--r70\"\n  }, ProductListBreadcrumb_jsx(Container[\"a\" /* default */], null, ProductListBreadcrumb_jsx(Row[\"a\" /* default */], {\n    className: \"align-items-center\"\n  }, ProductListBreadcrumb_jsx(Col[\"a\" /* default */], {\n    md: 6\n  }, ProductListBreadcrumb_jsx(\"div\", {\n    className: \"page-title\"\n  }, ProductListBreadcrumb_jsx(\"a\", null, children), ProductListBreadcrumb_jsx(\"h3\", {\n    className: \"breadcrumb-title\"\n  }, pageTitle))))));\n};\n\n/* harmony default export */ var ProductListBreadcrumb = (ProductListBreadcrumb_BreadcrumbOne);\n// CONCATENATED MODULE: ./src/components/Breadcrumb/index.js\n\n\n\n\n/***/ }),\n\n/***/ \"NKCw\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export Controller */\n/* unused harmony export FormProvider */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return appendErrors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return get; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return set; });\n/* unused harmony export useController */\n/* unused harmony export useFieldArray */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return useForm; });\n/* unused harmony export useFormContext */\n/* unused harmony export useFormState */\n/* unused harmony export useWatch */\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"q1tI\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nvar isNullOrUndefined = (value) => value == null;\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) &&\r\n    !Array.isArray(value) &&\r\n    isObjectType(value) &&\r\n    !(value instanceof Date);\n\nvar getControllerValue = (event) => isObject(event) && event.target\r\n    ? isCheckBoxInput(event.target)\r\n        ? event.target.checked\r\n        : event.target.value\r\n    : event;\n\nvar getNodeParentName = (name) => name.substring(0, name.search(/.\\d/)) || name;\n\nvar isNameInFieldArray = (names, name) => [...names].some((current) => getNodeParentName(name) === current);\n\nvar compact = (value) => value.filter(Boolean);\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj = {}, path, defaultValue) => {\r\n    const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n    return isUndefined(result) || result === obj\r\n        ? isUndefined(obj[path])\r\n            ? defaultValue\r\n            : obj[path]\r\n        : result;\r\n};\n\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n};\r\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n    onTouched: 'onTouched',\r\n    all: 'all',\r\n};\r\nconst SELECT = 'select';\r\nconst UNDEFINED = 'undefined';\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\n\nvar omit = (source, key) => {\r\n    const copy = Object.assign({}, source);\r\n    delete copy[key];\r\n    return copy;\r\n};\n\nconst FormContext = react__WEBPACK_IMPORTED_MODULE_0__[\"createContext\"](null);\r\nFormContext.displayName = 'RHFContext';\r\nconst useFormContext = () => react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"](FormContext);\r\nconst FormProvider = (props) => (react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"](FormContext.Provider, { value: omit(props, 'children') }, props.children));\n\nvar getProxyFormState = (isProxyEnabled, formState, readFormStateRef, localReadFormStateRef, isRoot = true) => isProxyEnabled\r\n    ? new Proxy(formState, {\r\n        get: (obj, prop) => {\r\n            if (prop in obj) {\r\n                if (readFormStateRef.current[prop] !== VALIDATION_MODE.all) {\r\n                    readFormStateRef.current[prop] = isRoot\r\n                        ? VALIDATION_MODE.all\r\n                        : true;\r\n                }\r\n                localReadFormStateRef &&\r\n                    (localReadFormStateRef.current[prop] = true);\r\n                return obj[prop];\r\n            }\r\n            return undefined;\r\n        },\r\n    })\r\n    : formState;\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nvar shouldRenderFormState = (formState, readFormStateRef, isRoot) => isEmptyObject(formState) ||\r\n    Object.keys(formState).length >= Object.keys(readFormStateRef).length ||\r\n    Object.keys(formState).find((key) => readFormStateRef[key] ===\r\n        (isRoot ? VALIDATION_MODE.all : true));\n\nvar isWeb = typeof window !== UNDEFINED &&\r\n    typeof window.HTMLElement !== UNDEFINED &&\r\n    typeof document !== UNDEFINED;\n\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nfunction useFormState(props) {\r\n    const methods = useFormContext();\r\n    const { formStateRef, formStateSubjectRef, readFormStateRef } = (props && props.control) || methods.control;\r\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"](formStateRef.current);\r\n    const readFormState = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"]({\r\n        isDirty: false,\r\n        dirtyFields: false,\r\n        touchedFields: false,\r\n        isValidating: false,\r\n        isValid: false,\r\n        errors: false,\r\n    });\r\n    react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"](() => {\r\n        const formStateSubscription = formStateSubjectRef.current.subscribe({\r\n            next: (formState) => {\r\n                shouldRenderFormState(formState, readFormState.current) &&\r\n                    updateFormState(Object.assign(Object.assign({}, formStateRef.current), formState));\r\n            },\r\n        });\r\n        return () => formStateSubscription.unsubscribe();\r\n    }, []);\r\n    return getProxyFormState(isProxyEnabled, formState, readFormStateRef, readFormState, false);\r\n}\n\nfunction useController({ name, rules, defaultValue, control, }) {\r\n    const methods = useFormContext();\r\n    const { defaultValuesRef, register, fieldsRef, fieldArrayNamesRef, controllerSubjectRef, } = control || methods.control;\r\n    const { onChange, onBlur, ref } = register(name, rules);\r\n    const [value, setInputStateValue] = react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"](isUndefined(get(fieldsRef.current, name)._f.value) ||\r\n        isNameInFieldArray(fieldArrayNamesRef.current, name)\r\n        ? isUndefined(defaultValue)\r\n            ? get(defaultValuesRef.current, name)\r\n            : defaultValue\r\n        : get(fieldsRef.current, name)._f.value);\r\n    const formState = useFormState({\r\n        control: control || methods.control,\r\n    });\r\n    get(fieldsRef.current, name)._f.value = value;\r\n    react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"](() => {\r\n        const controllerSubscription = controllerSubjectRef.current.subscribe({\r\n            next: (data) => (!data.name || name === data.name) &&\r\n                setInputStateValue(get(data.values, name)),\r\n        });\r\n        ref({\r\n            target: value,\r\n        });\r\n        return () => controllerSubscription.unsubscribe();\r\n    }, [name]);\r\n    return {\r\n        field: {\r\n            onChange: (event) => {\r\n                const value = getControllerValue(event);\r\n                setInputStateValue(value);\r\n                onChange({\r\n                    target: {\r\n                        value,\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.CHANGE,\r\n                });\r\n            },\r\n            onBlur: () => {\r\n                onBlur({\r\n                    target: {\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.BLUR,\r\n                });\r\n            },\r\n            name,\r\n            value,\r\n            ref,\r\n        },\r\n        formState,\r\n        fieldState: Object.defineProperties({}, {\r\n            invalid: {\r\n                get() {\r\n                    return !!get(formState.errors, name);\r\n                },\r\n            },\r\n            isDirty: {\r\n                get() {\r\n                    return !!get(formState.dirtyFields, name);\r\n                },\r\n            },\r\n            isTouched: {\r\n                get() {\r\n                    return !!get(formState.touchedFields, name);\r\n                },\r\n            },\r\n            error: {\r\n                get() {\r\n                    return get(formState.errors, name);\r\n                },\r\n            },\r\n        }),\r\n    };\r\n}\n\nconst Controller = (props) => props.render(useController(props));\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria\r\n    ? Object.assign(Object.assign({}, errors[name]), { types: Object.assign(Object.assign({}, (errors[name] && errors[name].types ? errors[name].types : {})), { [type]: message || true }) }) : {};\n\nvar isKey = (value) => /^\\w*$/.test(value);\n\nvar stringToPath = (input) => compact(input.replace(/[\"|']|\\]/g, '').split(/\\.|\\[/));\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || Array.isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nconst focusFieldBy = (fields, callback, fieldsNames) => {\r\n    for (const key of fieldsNames || Object.keys(fields)) {\r\n        const field = get(fields, key);\r\n        if (field) {\r\n            const _f = field._f;\r\n            const current = omit(field, '_f');\r\n            if (_f && callback(_f.name)) {\r\n                if (_f.ref.focus && isUndefined(_f.ref.focus())) {\r\n                    break;\r\n                }\r\n                else if (_f.refs) {\r\n                    _f.refs[0].focus();\r\n                    break;\r\n                }\r\n            }\r\n            else if (isObject(current)) {\r\n                focusFieldBy(current, callback);\r\n            }\r\n        }\r\n    }\r\n};\n\nconst getFieldsValues = (fieldsRef, defaultValuesRef = { current: {} }, output = {}) => {\r\n    for (const name in fieldsRef.current) {\r\n        const field = fieldsRef.current[name];\r\n        if (field) {\r\n            const _f = field._f;\r\n            const current = omit(field, '_f');\r\n            set(output, name, _f\r\n                ? _f.ref.disabled || (_f.refs && _f.refs.every((ref) => ref.disabled))\r\n                    ? undefined\r\n                    : _f.value\r\n                : Array.isArray(field)\r\n                    ? []\r\n                    : {});\r\n            if (current) {\r\n                getFieldsValues({\r\n                    current,\r\n                }, defaultValuesRef, output[name]);\r\n            }\r\n        }\r\n    }\r\n    return Object.assign(Object.assign({}, defaultValuesRef.current), output);\r\n};\n\nvar generateId = () => {\r\n    const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nvar mapIds = (values = [], keyName) => values.map((value) => (Object.assign({ [keyName]: (value && value[keyName]) || generateId() }, value)));\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepEqual(object1, object2, isErrorObject) {\r\n    if (isPrimitive(object1) ||\r\n        isPrimitive(object2) ||\r\n        object1 instanceof Date ||\r\n        object2 instanceof Date) {\r\n        return object1 === object2;\r\n    }\r\n    if (!react__WEBPACK_IMPORTED_MODULE_0__[\"isValidElement\"](object1)) {\r\n        const keys1 = Object.keys(object1);\r\n        const keys2 = Object.keys(object2);\r\n        if (keys1.length !== keys2.length) {\r\n            return false;\r\n        }\r\n        for (const key of keys1) {\r\n            const val1 = object1[key];\r\n            if (!(isErrorObject && key === 'ref')) {\r\n                const val2 = object2[key];\r\n                if ((isObject(val1) || Array.isArray(val1)) &&\r\n                    (isObject(val2) || Array.isArray(val2))\r\n                    ? !deepEqual(val1, val2, isErrorObject)\r\n                    : val1 !== val2) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n\nfunction deepMerge(target, source) {\r\n    if (isPrimitive(target) || isPrimitive(source)) {\r\n        return source;\r\n    }\r\n    for (const key in source) {\r\n        const targetValue = target[key];\r\n        const sourceValue = source[key];\r\n        try {\r\n            target[key] =\r\n                (isObject(targetValue) && isObject(sourceValue)) ||\r\n                    (Array.isArray(targetValue) && Array.isArray(sourceValue))\r\n                    ? deepMerge(targetValue, sourceValue)\r\n                    : sourceValue;\r\n        }\r\n        catch (_a) { }\r\n    }\r\n    return target;\r\n}\n\nfunction setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\r\n    let index = -1;\r\n    while (++index < values.length) {\r\n        for (const key in values[index]) {\r\n            if (Array.isArray(values[index][key])) {\r\n                !dirtyFields[index] && (dirtyFields[index] = {});\r\n                dirtyFields[index][key] = [];\r\n                setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\r\n            }\r\n            else {\r\n                deepEqual(get(defaultValues[index] || {}, key), values[index][key])\r\n                    ? set(dirtyFields[index] || {}, key)\r\n                    : (dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), { [key]: true }));\r\n            }\r\n        }\r\n        parentNode &&\r\n            !dirtyFields.length &&\r\n            delete parentNode[parentName];\r\n    }\r\n    return dirtyFields;\r\n}\r\nvar setFieldArrayDirtyFields = (values, defaultValues, dirtyFields) => deepMerge(setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)), setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)));\n\nfunction append(data, value) {\r\n    return [...data, ...(Array.isArray(value) ? value : [value])];\r\n}\n\nvar fillEmptyArray = (value) => Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...(Array.isArray(value) ? value : [value]),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar moveArrayAt = (data, from, to) => {\r\n    if (Array.isArray(data)) {\r\n        if (isUndefined(data[to])) {\r\n            data[to] = undefined;\r\n        }\r\n        data.splice(to, 0, data.splice(from, 1)[0]);\r\n        return data;\r\n    }\r\n    return [];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...(Array.isArray(value) ? value : [value]), ...data];\r\n}\n\nfunction removeAtIndexes(data, indexes) {\r\n    let i = 0;\r\n    const temp = [...data];\r\n    for (const index of indexes) {\r\n        temp.splice(index - i, 1);\r\n        i++;\r\n    }\r\n    return compact(temp).length ? temp : [];\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : removeAtIndexes(data, (Array.isArray(index) ? index : [index]).sort((a, b) => a - b));\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    data[indexA] = [data[indexB], (data[indexB] = data[indexA])][0];\r\n};\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\r\n    const length = updatePath.slice(0, -1).length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return object;\r\n}\r\nfunction unset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : stringToPath(path);\r\n    const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    let previousObjRef;\r\n    if (childObject) {\r\n        delete childObject[key];\r\n    }\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index &&\r\n                ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (Array.isArray(objectRef) &&\r\n                        !objectRef.filter((data) => (isObject(data) && !isEmptyObject(data)) || isBoolean(data)).length))) {\r\n                previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return object;\r\n}\n\nconst useFieldArray = ({ control, name, keyName = 'id', }) => {\r\n    const methods = useFormContext();\r\n    const focusNameRef = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"]('');\r\n    const { isWatchAllRef, watchFieldsRef, getFormIsDirty, watchSubjectRef, fieldArraySubjectRef, fieldArrayNamesRef, fieldsRef, defaultValuesRef, formStateRef, formStateSubjectRef, readFormStateRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValuesRef, } = control || methods.control;\r\n    const [fields, setFields] = react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"](mapIds(get(fieldArrayDefaultValuesRef.current, getNodeParentName(name))\r\n        ? get(fieldArrayDefaultValuesRef.current, name, [])\r\n        : get(defaultValuesRef.current, name, []), keyName));\r\n    set(fieldArrayDefaultValuesRef.current, name, [...fields]);\r\n    fieldArrayNamesRef.current.add(name);\r\n    const omitKey = (fields) => fields.map((field) => omit((field || {}), keyName));\r\n    const getCurrentFieldsValues = () => {\r\n        const values = get(getFieldsValues(fieldsRef, defaultValuesRef), name, []);\r\n        return mapIds(get(fieldArrayDefaultValuesRef.current, name, []).map((item, index) => (Object.assign(Object.assign({}, item), values[index]))), keyName);\r\n    };\r\n    const getFocusDetail = (index, options) => options\r\n        ? !isUndefined(options.focusIndex)\r\n            ? `${name}.${options.focusIndex}`\r\n            : options.focusName\r\n                ? options.focusName\r\n                : !options.shouldFocus\r\n                    ? ''\r\n                    : `${name}.${index}`\r\n        : `${name}.${index}`;\r\n    const resetFields = (index) => (Array.isArray(index) ? index : [index]).forEach((currentIndex) => set(fieldsRef.current, `${name}${isUndefined(currentIndex) ? '' : `.${currentIndex}`}`, isUndefined(currentIndex) ? [] : undefined));\r\n    const setFieldsAndNotify = (fieldsValues = []) => setFields(mapIds(fieldsValues, keyName));\r\n    const cleanup = (ref) => !compact(get(ref, name, [])).length && unset(ref, name);\r\n    const updateDirtyFieldsWithDefaultValues = (updatedFieldArrayValues) => updatedFieldArrayValues &&\r\n        set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n    const batchStateUpdate = (method, args, updatedFieldArrayValues = [], shouldSet = true) => {\r\n        if (get(fieldsRef.current, name)) {\r\n            const output = method(get(fieldsRef.current, name), args.argA, args.argB);\r\n            shouldSet && set(fieldsRef.current, name, output);\r\n        }\r\n        if (Array.isArray(get(formStateRef.current.errors, name))) {\r\n            const output = method(get(formStateRef.current.errors, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.errors, name, output);\r\n            cleanup(formStateRef.current.errors);\r\n        }\r\n        if (readFormStateRef.current.touchedFields &&\r\n            get(formStateRef.current.touchedFields, name)) {\r\n            const output = method(get(formStateRef.current.touchedFields, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.touchedFields, name, output);\r\n            cleanup(formStateRef.current.touchedFields);\r\n        }\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n            updateDirtyFieldsWithDefaultValues(updatedFieldArrayValues);\r\n            cleanup(formStateRef.current.dirtyFields);\r\n        }\r\n        if (readFormStateRef.current.isValid) {\r\n            set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));\r\n            cleanup(validFieldsRef.current);\r\n            set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));\r\n            cleanup(fieldsWithValidationRef.current);\r\n        }\r\n        formStateSubjectRef.current.next({\r\n            isDirty: getFormIsDirty(name, omitKey(updatedFieldArrayValues)),\r\n            errors: formStateRef.current.errors,\r\n            isValid: formStateRef.current.isValid,\r\n        });\r\n    };\r\n    const registerFieldArray = (values, index = 0, parentName = '') => values.forEach((appendValueItem, valueIndex) => !isPrimitive(appendValueItem) &&\r\n        Object.entries(appendValueItem).forEach(([key, value]) => {\r\n            const inputName = `${parentName || name}.${parentName ? valueIndex : index + valueIndex}.${key}`;\r\n            Array.isArray(value)\r\n                ? registerFieldArray(value, valueIndex, inputName)\r\n                : set(fieldsRef.current, inputName, {\r\n                    _f: {\r\n                        ref: {\r\n                            name: inputName,\r\n                        },\r\n                        name: inputName,\r\n                        value,\r\n                    },\r\n                });\r\n        }));\r\n    const append$1 = (value, options) => {\r\n        const appendValue = Array.isArray(value) ? value : [value];\r\n        const updatedFieldArrayValues = append(getCurrentFieldsValues(), appendValue);\r\n        const currentIndex = updatedFieldArrayValues.length - appendValue.length;\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(append, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues, false);\r\n        registerFieldArray(appendValue, currentIndex);\r\n        focusNameRef.current = getFocusDetail(currentIndex, options);\r\n    };\r\n    const prepend$1 = (value, options) => {\r\n        const prependValue = Array.isArray(value) ? value : [value];\r\n        const updatedFieldArrayValues = prepend(getCurrentFieldsValues(), prependValue);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(prepend, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues);\r\n        registerFieldArray(prependValue);\r\n        focusNameRef.current = getFocusDetail(0, options);\r\n    };\r\n    const remove = (index) => {\r\n        const updatedFieldArrayValues = removeArrayAt(getCurrentFieldsValues(), index);\r\n        resetFields(index);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(removeArrayAt, {\r\n            argA: index,\r\n        }, updatedFieldArrayValues);\r\n    };\r\n    const insert$1 = (index, value, options) => {\r\n        const insertValue = Array.isArray(value) ? value : [value];\r\n        const updatedFieldArrayValues = insert(getCurrentFieldsValues(), index, insertValue);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(insert, {\r\n            argA: index,\r\n            argB: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues);\r\n        registerFieldArray(insertValue, index);\r\n        focusNameRef.current = getFocusDetail(index, options);\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        swapArrayAt(fieldValues, indexA, indexB);\r\n        batchStateUpdate(swapArrayAt, {\r\n            argA: indexA,\r\n            argB: indexB,\r\n        }, fieldValues, false);\r\n        setFieldsAndNotify(fieldValues);\r\n    };\r\n    const move = (from, to) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        moveArrayAt(fieldValues, from, to);\r\n        setFieldsAndNotify(fieldValues);\r\n        batchStateUpdate(moveArrayAt, {\r\n            argA: from,\r\n            argB: to,\r\n        }, fieldValues, false);\r\n    };\r\n    react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"](() => {\r\n        if (isWatchAllRef.current) {\r\n            formStateSubjectRef.current.next({});\r\n        }\r\n        else {\r\n            for (const watchField of watchFieldsRef.current) {\r\n                if (name.startsWith(watchField)) {\r\n                    formStateSubjectRef.current.next({});\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        watchSubjectRef.current.next({\r\n            name,\r\n            value: get(getFieldsValues(fieldsRef, defaultValuesRef), name, []),\r\n        });\r\n        focusNameRef.current &&\r\n            focusFieldBy(fieldsRef.current, (key) => key.startsWith(focusNameRef.current));\r\n        focusNameRef.current = '';\r\n        fieldArraySubjectRef.current.next({\r\n            name,\r\n            fields: omitKey([...fields]),\r\n        });\r\n    }, [fields, name]);\r\n    react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"](() => {\r\n        const fieldArraySubscription = fieldArraySubjectRef.current.subscribe({\r\n            next({ name: inputFieldArrayName, fields, isReset }) {\r\n                if (isReset) {\r\n                    unset(fieldsRef.current, inputFieldArrayName || name);\r\n                    inputFieldArrayName\r\n                        ? set(fieldArrayDefaultValuesRef.current, inputFieldArrayName, fields)\r\n                        : (fieldArrayDefaultValuesRef.current = fields);\r\n                    setFieldsAndNotify(get(fieldArrayDefaultValuesRef.current, name));\r\n                }\r\n            },\r\n        });\r\n        !get(fieldsRef.current, name) && set(fieldsRef.current, name, []);\r\n        return () => {\r\n            fieldArrayDefaultValuesRef.current = getFieldsValues(fieldsRef);\r\n            fieldArraySubscription.unsubscribe();\r\n        };\r\n    }, []);\r\n    return {\r\n        swap: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](swap, [name]),\r\n        move: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](move, [name]),\r\n        prepend: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](prepend$1, [name]),\r\n        append: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](append$1, [name]),\r\n        remove: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](remove, [name]),\r\n        insert: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](insert$1, [name]),\r\n        fields: fields,\r\n    };\r\n};\n\nfunction getFields(fieldsNames, fieldsRefs) {\r\n    const currentFields = {};\r\n    for (const name of fieldsNames) {\r\n        const field = get(fieldsRefs, name);\r\n        if (field) {\r\n            !isKey(name)\r\n                ? set(currentFields, name, field._f)\r\n                : (currentFields[name] = field._f);\r\n        }\r\n    }\r\n    return currentFields;\r\n}\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isMultipleSelect = (element) => element.type === `${SELECT}-multiple`;\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (Array.isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.checked && !option.disabled)\r\n                .map((option) => option.value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        return options[0].checked && !options[0].disabled\r\n            ? // @ts-expect-error expected to work in the browser\r\n                options[0].attributes && !isUndefined(options[0].attributes.value)\r\n                    ? isUndefined(options[0].value) || options[0].value === ''\r\n                        ? validResult\r\n                        : { value: options[0].value, isValid: true }\r\n                    : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nvar getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => valueAsNumber\r\n    ? value === ''\r\n        ? NaN\r\n        : +value\r\n    : valueAsDate\r\n        ? new Date(value)\r\n        : setValueAs\r\n            ? setValueAs(value)\r\n            : value;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: null,\r\n};\r\nvar getRadioValue = (options) => Array.isArray(options)\r\n    ? options.reduce((previous, option) => option && option.checked && !option.disabled\r\n        ? {\r\n            isValid: true,\r\n            value: option.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nfunction getFieldValue(field) {\r\n    if (field && field._f) {\r\n        const ref = field._f.ref;\r\n        if (ref.disabled) {\r\n            return;\r\n        }\r\n        if (isFileInput(ref)) {\r\n            return ref.files;\r\n        }\r\n        if (isRadioInput(ref)) {\r\n            return getRadioValue(field._f.refs).value;\r\n        }\r\n        if (isMultipleSelect(ref)) {\r\n            return getMultipleSelectValue(ref.options);\r\n        }\r\n        if (isCheckBoxInput(ref)) {\r\n            return getCheckboxValue(field._f.refs).value;\r\n        }\r\n        return getFieldValueAs(isUndefined(ref.value) ? field._f.ref.value : ref.value, field._f);\r\n    }\r\n}\n\nvar skipValidation = ({ isOnBlur, isOnChange, isOnTouch, isTouched, isReValidateOnBlur, isReValidateOnChange, isBlurEvent, isSubmitted, isOnAll, }) => {\r\n    if (isOnAll) {\r\n        return false;\r\n    }\r\n    else if (!isSubmitted && isOnTouch) {\r\n        return !(isTouched || isBlurEvent);\r\n    }\r\n    else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\r\n        return !isBlurEvent;\r\n    }\r\n    else if (isSubmitted ? isReValidateOnChange : isOnChange) {\r\n        return isBlurEvent;\r\n    }\r\n    return true;\r\n};\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isString = (value) => typeof value === 'string';\n\nvar isMessage = (value) => isString(value) || react__WEBPACK_IMPORTED_MODULE_0__[\"isValidElement\"](value);\n\nvar isRegex = (value) => value instanceof RegExp;\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) || (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData)\r\n    ? validationData\r\n    : {\r\n        value: validationData,\r\n        message: '',\r\n    };\n\nvar validateField = async ({ _f: { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, value: inputValue, valueAsNumber, }, }, validateAllFieldCriteria) => {\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = ((valueAsNumber || isFileInput(ref)) && !ref.value) ||\r\n        inputValue === '' ||\r\n        (Array.isArray(inputValue) && !inputValue.length);\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, appendErrorsCurry(exceedMax ? maxType : minType, message));\r\n    };\r\n    if (required &&\r\n        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(inputValue))) ||\r\n            (isBoolean(inputValue) && !inputValue) ||\r\n            (isCheckBox && !getCheckboxValue(refs).isValid) ||\r\n            (isRadio && !getRadioValue(refs).isValid))) {\r\n        const { value, message } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (value) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message, ref: isRadioOrCheckbox ? (refs || [])[0] || {} : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if ((!isNullOrUndefined(min) || !isNullOrUndefined(max)) &&\r\n        inputValue !== '') {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const maxOutput = getValueAndMessage(max);\r\n        const minOutput = getValueAndMessage(min);\r\n        if (!isNaN(inputValue)) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(inputValue);\r\n            if (!isNullOrUndefined(maxOutput.value)) {\r\n                exceedMax = valueNumber > maxOutput.value;\r\n            }\r\n            if (!isNullOrUndefined(minOutput.value)) {\r\n                exceedMin = valueNumber < minOutput.value;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(inputValue);\r\n            if (isString(maxOutput.value)) {\r\n                exceedMax = valueDate > new Date(maxOutput.value);\r\n            }\r\n            if (isString(minOutput.value)) {\r\n                exceedMin = valueDate < new Date(minOutput.value);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(inputValue) && !isEmpty && (maxLength || minLength)) {\r\n        const maxLengthOutput = getValueAndMessage(maxLength);\r\n        const minLengthOutput = getValueAndMessage(minLength);\r\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&\r\n            inputValue.length > maxLengthOutput.value;\r\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&\r\n            inputValue.length < minLengthOutput.value;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(inputValue) && pattern && !isEmpty) {\r\n        const { value: patternValue, message } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !inputValue.match(patternValue)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message,\r\n                ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        const validateRef = isRadioOrCheckbox && refs ? refs[0] : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(inputValue);\r\n            const validateError = getValidateError(result, validateRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const [key, validateFunction] of Object.entries(validate)) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateResult = await validateFunction(inputValue);\r\n                const validateError = getValidateError(validateResult, validateRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: validateRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return error;\r\n};\n\nvar getValidationModes = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n    isOnAll: mode === VALIDATION_MODE.all,\r\n    isOnTouch: mode === VALIDATION_MODE.onTouched,\r\n});\n\nvar isHTMLElement = (value) => value instanceof HTMLElement;\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nclass Subscription {\r\n    constructor() {\r\n        this.tearDowns = [];\r\n    }\r\n    add(tearDown) {\r\n        this.tearDowns.push(tearDown);\r\n    }\r\n    unsubscribe() {\r\n        for (const teardown of this.tearDowns) {\r\n            teardown();\r\n        }\r\n        this.tearDowns = [];\r\n    }\r\n}\r\nclass Subscriber {\r\n    constructor(observer, subscription) {\r\n        this.observer = observer;\r\n        this.closed = false;\r\n        subscription.add(() => (this.closed = true));\r\n    }\r\n    next(value) {\r\n        if (!this.closed) {\r\n            this.observer.next(value);\r\n        }\r\n    }\r\n}\r\nclass Subject {\r\n    constructor() {\r\n        this.observers = [];\r\n    }\r\n    next(value) {\r\n        for (const observer of this.observers) {\r\n            observer.next(value);\r\n        }\r\n    }\r\n    subscribe(observer) {\r\n        const subscription = new Subscription();\r\n        const subscriber = new Subscriber(observer, subscription);\r\n        this.observers.push(subscriber);\r\n        return subscription;\r\n    }\r\n    unsubscribe() {\r\n        this.observers = [];\r\n    }\r\n}\n\nconst isWindowUndefined = typeof window === UNDEFINED;\r\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, resolver, context, defaultValues = {}, shouldFocusError = true, criteriaMode, } = {}) {\r\n    const fieldsRef = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"]({});\r\n    const fieldsNamesRef = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"](new Set());\r\n    const formStateSubjectRef = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"](new Subject());\r\n    const watchSubjectRef = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"](new Subject());\r\n    const controllerSubjectRef = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"](new Subject());\r\n    const fieldArraySubjectRef = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"](new Subject());\r\n    const fieldArrayDefaultValuesRef = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"]({});\r\n    const watchFieldsRef = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"](new Set());\r\n    const isMountedRef = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"](false);\r\n    const fieldsWithValidationRef = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"]({});\r\n    const validFieldsRef = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"]({});\r\n    const defaultValuesRef = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"](defaultValues);\r\n    const isWatchAllRef = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"](false);\r\n    const contextRef = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"](context);\r\n    const resolverRef = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"](resolver);\r\n    const fieldArrayNamesRef = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"](new Set());\r\n    const validationMode = getValidationModes(mode);\r\n    const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\r\n    const [formState, setFormState] = react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"]({\r\n        isDirty: false,\r\n        isValidating: false,\r\n        dirtyFields: {},\r\n        isSubmitted: false,\r\n        submitCount: 0,\r\n        touchedFields: {},\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: !validationMode.isOnSubmit,\r\n        errors: {},\r\n    });\r\n    const readFormStateRef = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"]({\r\n        isDirty: !isProxyEnabled,\r\n        dirtyFields: !isProxyEnabled,\r\n        touchedFields: !isProxyEnabled,\r\n        isValidating: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n        errors: !isProxyEnabled,\r\n    });\r\n    const formStateRef = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"](formState);\r\n    contextRef.current = context;\r\n    resolverRef.current = resolver;\r\n    const getIsValid = () => (formStateRef.current.isValid =\r\n        deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\r\n            isEmptyObject(formStateRef.current.errors));\r\n    const shouldRenderBaseOnError = react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"]((name, error, shouldRender = false, state = {}, isValid, isWatched) => {\r\n        const previousError = get(formStateRef.current.errors, name);\r\n        let shouldReRender = shouldRender ||\r\n            !deepEqual(previousError, error, true) ||\r\n            (readFormStateRef.current.isValid &&\r\n                isUndefined(error) &&\r\n                get(fieldsWithValidationRef.current, name) &&\r\n                !get(validFieldsRef.current, name));\r\n        if (error) {\r\n            unset(validFieldsRef.current, name);\r\n            shouldReRender =\r\n                shouldReRender ||\r\n                    !previousError ||\r\n                    !deepEqual(previousError, error, true);\r\n            set(formStateRef.current.errors, name, error);\r\n        }\r\n        else {\r\n            if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\r\n                set(validFieldsRef.current, name, true);\r\n                shouldReRender = shouldReRender || previousError;\r\n            }\r\n            unset(formStateRef.current.errors, name);\r\n        }\r\n        if ((shouldReRender && !isNullOrUndefined(shouldRender)) ||\r\n            !isEmptyObject(state) ||\r\n            isWatched) {\r\n            const updatedFormState = Object.assign(Object.assign({}, state), { isValid: resolverRef.current ? !!isValid : getIsValid(), errors: formStateRef.current.errors });\r\n            formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), updatedFormState);\r\n            formStateSubjectRef.current.next(isWatched ? {} : updatedFormState);\r\n        }\r\n        formStateSubjectRef.current.next({\r\n            isValidating: false,\r\n        });\r\n    }, []);\r\n    const setFieldValue = react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"]((name, rawValue, options = {}, shouldRender, shouldRegister) => {\r\n        shouldRegister && register(name);\r\n        const _f = get(fieldsRef.current, name, {})._f;\r\n        if (_f) {\r\n            const value = isWeb && isHTMLElement(_f.ref) && isNullOrUndefined(rawValue)\r\n                ? ''\r\n                : rawValue;\r\n            _f.value = rawValue;\r\n            if (isRadioInput(_f.ref)) {\r\n                (_f.refs || []).forEach((radioRef) => (radioRef.checked = radioRef.value === value));\r\n            }\r\n            else if (isFileInput(_f.ref) && !isString(value)) {\r\n                _f.ref.files = value;\r\n            }\r\n            else if (isMultipleSelect(_f.ref)) {\r\n                [..._f.ref.options].forEach((selectRef) => (selectRef.selected = value.includes(selectRef.value)));\r\n            }\r\n            else if (isCheckBoxInput(_f.ref) && _f.refs) {\r\n                _f.refs.length > 1\r\n                    ? _f.refs.forEach((checkboxRef) => (checkboxRef.checked = Array.isArray(value)\r\n                        ? !!value.find((data) => data === checkboxRef.value)\r\n                        : value === checkboxRef.value))\r\n                    : (_f.refs[0].checked = !!value);\r\n            }\r\n            else {\r\n                _f.ref.value = value;\r\n            }\r\n            if (shouldRender) {\r\n                const values = getFieldsValues(fieldsRef);\r\n                set(values, name, rawValue);\r\n                controllerSubjectRef.current.next({\r\n                    values: Object.assign(Object.assign({}, defaultValuesRef.current), values),\r\n                    name,\r\n                });\r\n            }\r\n            options.shouldDirty && updateAndGetDirtyState(name, value);\r\n            options.shouldValidate && trigger(name);\r\n        }\r\n    }, []);\r\n    const getFormIsDirty = react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"]((name, data) => {\r\n        if (readFormStateRef.current.isDirty) {\r\n            const formValues = getFieldsValues(fieldsRef);\r\n            name && data && set(formValues, name, data);\r\n            return !deepEqual(formValues, defaultValuesRef.current);\r\n        }\r\n        return false;\r\n    }, []);\r\n    const updateAndGetDirtyState = react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"]((name, inputValue, shouldRender = true) => {\r\n        if (readFormStateRef.current.isDirty ||\r\n            readFormStateRef.current.dirtyFields) {\r\n            const isFieldDirty = !deepEqual(get(defaultValuesRef.current, name), inputValue);\r\n            const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\r\n            const previousIsDirty = formStateRef.current.isDirty;\r\n            isFieldDirty\r\n                ? set(formStateRef.current.dirtyFields, name, true)\r\n                : unset(formStateRef.current.dirtyFields, name);\r\n            formStateRef.current.isDirty = getFormIsDirty();\r\n            const state = {\r\n                isDirty: formStateRef.current.isDirty,\r\n                dirtyFields: formStateRef.current.dirtyFields,\r\n            };\r\n            const isChanged = (readFormStateRef.current.isDirty &&\r\n                previousIsDirty !== state.isDirty) ||\r\n                (readFormStateRef.current.dirtyFields &&\r\n                    isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\r\n            isChanged && shouldRender && formStateSubjectRef.current.next(state);\r\n            return isChanged ? state : {};\r\n        }\r\n        return {};\r\n    }, []);\r\n    const executeValidation = react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](async (name, skipReRender) => {\r\n        const error = (await validateField(get(fieldsRef.current, name), isValidateAllFieldCriteria))[name];\r\n        shouldRenderBaseOnError(name, error, skipReRender);\r\n        return isUndefined(error);\r\n    }, [isValidateAllFieldCriteria]);\r\n    const executeSchemaOrResolverValidation = react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](async (names, currentNames = []) => {\r\n        const { errors } = await resolverRef.current(getFieldsValues(fieldsRef, defaultValuesRef), contextRef.current, {\r\n            criteriaMode,\r\n            names: currentNames,\r\n            fields: getFields(fieldsNamesRef.current, fieldsRef.current),\r\n        });\r\n        for (const name of names) {\r\n            const error = get(errors, name);\r\n            error\r\n                ? set(formStateRef.current.errors, name, error)\r\n                : unset(formStateRef.current.errors, name);\r\n        }\r\n        return errors;\r\n    }, [criteriaMode]);\r\n    const validateForm = async (fieldsRef) => {\r\n        for (const name in fieldsRef) {\r\n            const field = fieldsRef[name];\r\n            if (field) {\r\n                const _f = field._f;\r\n                const current = omit(field, '_f');\r\n                if (_f) {\r\n                    const fieldError = await validateField(field, isValidateAllFieldCriteria);\r\n                    if (fieldError[_f.name]) {\r\n                        set(formStateRef.current.errors, _f.name, fieldError[_f.name]);\r\n                        unset(validFieldsRef.current, _f.name);\r\n                    }\r\n                    else if (get(fieldsWithValidationRef.current, _f.name)) {\r\n                        set(validFieldsRef.current, _f.name, true);\r\n                        unset(formStateRef.current.errors, _f.name);\r\n                    }\r\n                }\r\n                current && (await validateForm(current));\r\n            }\r\n        }\r\n    };\r\n    const trigger = react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](async (name) => {\r\n        const fields = isUndefined(name)\r\n            ? Object.keys(fieldsRef.current)\r\n            : Array.isArray(name)\r\n                ? name\r\n                : [name];\r\n        let isValid;\r\n        formStateSubjectRef.current.next({\r\n            isValidating: true,\r\n        });\r\n        if (resolverRef.current) {\r\n            isValid = isEmptyObject(await executeSchemaOrResolverValidation(fields, isUndefined(name)\r\n                ? undefined\r\n                : fields));\r\n        }\r\n        else {\r\n            isUndefined(name)\r\n                ? await validateForm(fieldsRef.current)\r\n                : await Promise.all(fields.map(async (data) => await executeValidation(data, null)));\r\n        }\r\n        formStateSubjectRef.current.next({\r\n            errors: formStateRef.current.errors,\r\n            isValidating: false,\r\n            isValid: resolverRef.current ? isValid : getIsValid(),\r\n        });\r\n    }, [executeSchemaOrResolverValidation, executeValidation]);\r\n    const setInternalValues = react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"]((name, value, options) => Object.entries(value).forEach(([inputKey, inputValue]) => {\r\n        const fieldName = `${name}.${inputKey}`;\r\n        const field = get(fieldsRef.current, fieldName);\r\n        field && !field._f\r\n            ? setInternalValues(fieldName, inputValue, options)\r\n            : setFieldValue(fieldName, inputValue, options, true, !field);\r\n    }), [trigger]);\r\n    const isFieldWatched = (name) => isWatchAllRef.current ||\r\n        watchFieldsRef.current.has(name) ||\r\n        watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\r\n    const updateValidAndValue = (name, options, isWithinRefCallback) => {\r\n        let defaultValue;\r\n        const field = get(fieldsRef.current, name);\r\n        const useFormDefaultValue = get(defaultValuesRef.current, name);\r\n        if (field &&\r\n            (!isEmptyObject(defaultValuesRef.current) || !isUndefined(field._f.value))) {\r\n            defaultValue = isUndefined(field._f.value)\r\n                ? useFormDefaultValue\r\n                : field._f.value;\r\n            if (!isNullOrUndefined(defaultValue)) {\r\n                setFieldValue(name, defaultValue);\r\n            }\r\n        }\r\n        if ((useFormDefaultValue || (!useFormDefaultValue && isWithinRefCallback)) &&\r\n            options &&\r\n            !validationMode.isOnSubmit &&\r\n            field &&\r\n            readFormStateRef.current.isValid) {\r\n            validateField(field, isValidateAllFieldCriteria).then((error) => {\r\n                isEmptyObject(error)\r\n                    ? set(validFieldsRef.current, name, true)\r\n                    : unset(validFieldsRef.current, name);\r\n                formStateRef.current.isValid &&\r\n                    !isEmptyObject(error) &&\r\n                    setFormState(Object.assign(Object.assign({}, formStateRef.current), { isValid: getIsValid() }));\r\n            });\r\n        }\r\n        return defaultValue;\r\n    };\r\n    const setValue = (name, value, options = {}) => {\r\n        isMountedRef.current = true;\r\n        const field = get(fieldsRef.current, name);\r\n        const isFieldArray = fieldArrayNamesRef.current.has(name);\r\n        if (isFieldArray) {\r\n            fieldArraySubjectRef.current.next({\r\n                fields: value,\r\n                name,\r\n                isReset: true,\r\n            });\r\n            if ((readFormStateRef.current.isDirty ||\r\n                readFormStateRef.current.dirtyFields) &&\r\n                options.shouldDirty) {\r\n                set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n                formStateSubjectRef.current.next({\r\n                    dirtyFields: formStateRef.current.dirtyFields,\r\n                    isDirty: getFormIsDirty(name, value),\r\n                });\r\n            }\r\n            !value.length &&\r\n                set(fieldsRef.current, name, []) &&\r\n                set(fieldArrayDefaultValuesRef.current, name, []);\r\n        }\r\n        (field && !field._f) || isFieldArray\r\n            ? setInternalValues(name, value, isFieldArray ? {} : options)\r\n            : setFieldValue(name, value, options, true, !field);\r\n        isFieldWatched(name) && formStateSubjectRef.current.next({});\r\n        watchSubjectRef.current.next({ name, value });\r\n    };\r\n    const handleChange = react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](async ({ type, target, target: { value, type: inputType } }) => {\r\n        let name = target.name;\r\n        let error;\r\n        let isValid;\r\n        const field = get(fieldsRef.current, name);\r\n        if (field) {\r\n            let inputValue = inputType ? getFieldValue(field) : undefined;\r\n            inputValue = isUndefined(inputValue) ? value : inputValue;\r\n            const isBlurEvent = type === EVENTS.BLUR;\r\n            const { isOnBlur: isReValidateOnBlur, isOnChange: isReValidateOnChange, } = getValidationModes(reValidateMode);\r\n            const shouldSkipValidation = skipValidation(Object.assign({ isBlurEvent, isTouched: !!get(formStateRef.current.touchedFields, name), isSubmitted: formStateRef.current.isSubmitted, isReValidateOnBlur,\r\n                isReValidateOnChange }, validationMode));\r\n            const isWatched = !isBlurEvent && isFieldWatched(name);\r\n            if (!isUndefined(inputValue)) {\r\n                field._f.value = inputValue;\r\n            }\r\n            const state = updateAndGetDirtyState(name, field._f.value, false);\r\n            if (isBlurEvent && !get(formStateRef.current.touchedFields, name)) {\r\n                set(formStateRef.current.touchedFields, name, true);\r\n                readFormStateRef.current.touchedFields &&\r\n                    (state.touchedFields = formStateRef.current.touchedFields);\r\n            }\r\n            let shouldRender = !isEmptyObject(state) || isWatched;\r\n            if (shouldSkipValidation) {\r\n                !isBlurEvent &&\r\n                    watchSubjectRef.current.next({\r\n                        name,\r\n                        type,\r\n                        value: inputValue,\r\n                    });\r\n                return (shouldRender &&\r\n                    formStateSubjectRef.current.next(isWatched ? {} : state));\r\n            }\r\n            formStateSubjectRef.current.next({\r\n                isValidating: true,\r\n            });\r\n            if (resolverRef.current) {\r\n                const { errors } = await resolverRef.current(getFieldsValues(fieldsRef, defaultValuesRef), contextRef.current, {\r\n                    criteriaMode,\r\n                    fields: getFields([name], fieldsRef.current),\r\n                    names: [name],\r\n                });\r\n                const previousFormIsValid = formStateRef.current.isValid;\r\n                error = get(errors, name);\r\n                if (isCheckBoxInput(target) && !error) {\r\n                    const parentNodeName = getNodeParentName(name);\r\n                    const currentError = get(errors, parentNodeName, {});\r\n                    currentError.type && currentError.message && (error = currentError);\r\n                    if (currentError ||\r\n                        get(formStateRef.current.errors, parentNodeName)) {\r\n                        name = parentNodeName;\r\n                    }\r\n                }\r\n                isValid = isEmptyObject(errors);\r\n                previousFormIsValid !== isValid && (shouldRender = true);\r\n            }\r\n            else {\r\n                error = (await validateField(field, isValidateAllFieldCriteria))[name];\r\n            }\r\n            !isBlurEvent &&\r\n                watchSubjectRef.current.next({\r\n                    name,\r\n                    type,\r\n                    value: inputValue,\r\n                });\r\n            shouldRenderBaseOnError(name, error, shouldRender, state, isValid, isWatched);\r\n        }\r\n    }, []);\r\n    const getValues = (fieldNames) => {\r\n        const values = isMountedRef.current\r\n            ? getFieldsValues(fieldsRef, defaultValuesRef)\r\n            : defaultValuesRef.current;\r\n        return isUndefined(fieldNames)\r\n            ? values\r\n            : isString(fieldNames)\r\n                ? get(values, fieldNames)\r\n                : fieldNames.map((name) => get(values, name));\r\n    };\r\n    const updateIsValid = react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](async (values = {}) => {\r\n        const previousIsValid = formStateRef.current.isValid;\r\n        if (resolver) {\r\n            const { errors } = await resolverRef.current(Object.assign(Object.assign({}, getFieldsValues(fieldsRef, defaultValuesRef)), values), contextRef.current, {\r\n                criteriaMode,\r\n                fields: getFields(fieldsNamesRef.current, fieldsRef.current),\r\n            });\r\n            formStateRef.current.isValid = isEmptyObject(errors);\r\n        }\r\n        else {\r\n            getIsValid();\r\n        }\r\n        previousIsValid !== formStateRef.current.isValid &&\r\n            formStateSubjectRef.current.next({\r\n                isValid: formStateRef.current.isValid,\r\n            });\r\n    }, [criteriaMode]);\r\n    const clearErrors = (name) => {\r\n        name &&\r\n            (Array.isArray(name) ? name : [name]).forEach((inputName) => unset(formStateRef.current.errors, inputName));\r\n        formStateSubjectRef.current.next({\r\n            errors: name ? formStateRef.current.errors : {},\r\n        });\r\n    };\r\n    const setError = (name, error, options) => {\r\n        const ref = ((get(fieldsRef.current, name) || { _f: {} })._f || {}).ref;\r\n        set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), { ref }));\r\n        formStateSubjectRef.current.next({\r\n            errors: formStateRef.current.errors,\r\n            isValid: false,\r\n        });\r\n        options && options.shouldFocus && ref && ref.focus && ref.focus();\r\n    };\r\n    const watchInternal = react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"]((fieldNames, defaultValue, isGlobal) => {\r\n        const isArrayNames = Array.isArray(fieldNames);\r\n        const fieldValues = isMountedRef.current\r\n            ? getValues()\r\n            : isUndefined(defaultValue)\r\n                ? defaultValuesRef.current\r\n                : isArrayNames\r\n                    ? defaultValue || {}\r\n                    : { [fieldNames]: defaultValue };\r\n        if (isUndefined(fieldNames)) {\r\n            isGlobal && (isWatchAllRef.current = true);\r\n            return fieldValues;\r\n        }\r\n        const result = [];\r\n        for (const fieldName of isArrayNames ? fieldNames : [fieldNames]) {\r\n            isGlobal && watchFieldsRef.current.add(fieldName);\r\n            result.push(get(fieldValues, fieldName));\r\n        }\r\n        return isArrayNames ? result : result[0];\r\n    }, []);\r\n    const watch = (fieldName, defaultValue) => isFunction(fieldName)\r\n        ? watchSubjectRef.current.subscribe({\r\n            next: (info) => fieldName(watchInternal(undefined, defaultValue), info),\r\n        })\r\n        : watchInternal(fieldName, defaultValue, true);\r\n    const unregister = (name, options = {}) => {\r\n        for (const inputName of name\r\n            ? Array.isArray(name)\r\n                ? name\r\n                : [name]\r\n            : Object.keys(fieldsNamesRef.current)) {\r\n            fieldsNamesRef.current.delete(inputName);\r\n            fieldArrayNamesRef.current.delete(inputName);\r\n            if (get(fieldsRef.current, inputName)) {\r\n                if (!options.keepIsValid) {\r\n                    unset(fieldsWithValidationRef.current, inputName);\r\n                    unset(validFieldsRef.current, inputName);\r\n                }\r\n                !options.keepError && unset(formStateRef.current.errors, inputName);\r\n                !options.keepValue && unset(fieldsRef.current, inputName);\r\n                !options.keepDirty &&\r\n                    unset(formStateRef.current.dirtyFields, inputName);\r\n                !options.keepTouched &&\r\n                    unset(formStateRef.current.touchedFields, inputName);\r\n                !options.keepDefaultValue && unset(defaultValuesRef.current, inputName);\r\n                watchSubjectRef.current.next({\r\n                    name: inputName,\r\n                });\r\n            }\r\n        }\r\n        formStateSubjectRef.current.next(Object.assign(Object.assign(Object.assign({}, formStateRef.current), (!options.keepDirty ? {} : { isDirty: getFormIsDirty() })), (resolverRef.current ? {} : { isValid: getIsValid() })));\r\n        if (!options.keepIsValid) {\r\n            updateIsValid();\r\n        }\r\n    };\r\n    const registerFieldRef = (name, ref, options) => {\r\n        let field = get(fieldsRef.current, name);\r\n        if (field) {\r\n            const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n            if (ref === field._f.ref ||\r\n                (isWeb && isHTMLElement(field._f.ref) && !isHTMLElement(ref)) ||\r\n                (isRadioOrCheckbox &&\r\n                    Array.isArray(field._f.refs) &&\r\n                    compact(field._f.refs).find((option) => option === ref))) {\r\n                return;\r\n            }\r\n            field = {\r\n                _f: isRadioOrCheckbox\r\n                    ? Object.assign(Object.assign({}, field._f), { refs: [\r\n                            ...compact(field._f.refs || []).filter((ref) => isHTMLElement(ref) && document.contains(ref)),\r\n                            ref,\r\n                        ], ref: { type: ref.type, name } }) : Object.assign(Object.assign({}, field._f), { ref }),\r\n            };\r\n            set(fieldsRef.current, name, field);\r\n            const defaultValue = updateValidAndValue(name, options, true);\r\n            if (isRadioOrCheckbox && Array.isArray(defaultValue)\r\n                ? !deepEqual(get(fieldsRef.current, name)._f.value, defaultValue)\r\n                : isUndefined(get(fieldsRef.current, name)._f.value)) {\r\n                get(fieldsRef.current, name)._f.value = getFieldValue(get(fieldsRef.current, name));\r\n            }\r\n        }\r\n    };\r\n    const register = react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"]((name, options) => {\r\n        const isInitialRegister = !get(fieldsRef.current, name);\r\n        set(fieldsRef.current, name, {\r\n            _f: Object.assign(Object.assign(Object.assign({}, (isInitialRegister\r\n                ? { ref: { name } }\r\n                : Object.assign({ ref: (get(fieldsRef.current, name)._f || {}).ref }, get(fieldsRef.current, name)._f))), { name }), options),\r\n        });\r\n        options && set(fieldsWithValidationRef.current, name, true);\r\n        fieldsNamesRef.current.add(name);\r\n        isInitialRegister && updateValidAndValue(name, options);\r\n        return isWindowUndefined\r\n            ? { name: name }\r\n            : {\r\n                name,\r\n                onChange: handleChange,\r\n                onBlur: handleChange,\r\n                ref: (ref) => ref && registerFieldRef(name, ref, options),\r\n            };\r\n    }, [defaultValuesRef.current]);\r\n    const handleSubmit = react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"]((onValid, onInvalid) => async (e) => {\r\n        if (e && e.preventDefault) {\r\n            e.preventDefault();\r\n            e.persist();\r\n        }\r\n        let fieldValues = Object.assign(Object.assign({}, defaultValuesRef.current), getFieldsValues(fieldsRef, defaultValuesRef));\r\n        formStateSubjectRef.current.next({\r\n            isSubmitting: true,\r\n        });\r\n        try {\r\n            if (resolverRef.current) {\r\n                const { errors, values } = await resolverRef.current(fieldValues, contextRef.current, {\r\n                    criteriaMode,\r\n                    fields: getFields(fieldsNamesRef.current, fieldsRef.current),\r\n                });\r\n                formStateRef.current.errors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                await validateForm(fieldsRef.current);\r\n            }\r\n            if (isEmptyObject(formStateRef.current.errors) &&\r\n                Object.keys(formStateRef.current.errors).every((name) => get(fieldValues, name))) {\r\n                formStateSubjectRef.current.next({\r\n                    errors: {},\r\n                    isSubmitting: true,\r\n                });\r\n                await onValid(fieldValues, e);\r\n            }\r\n            else {\r\n                onInvalid && (await onInvalid(formStateRef.current.errors, e));\r\n                shouldFocusError &&\r\n                    focusFieldBy(fieldsRef.current, (key) => get(formStateRef.current.errors, key), fieldsNamesRef.current);\r\n            }\r\n        }\r\n        finally {\r\n            formStateRef.current.isSubmitted = true;\r\n            formStateSubjectRef.current.next({\r\n                isSubmitted: true,\r\n                isSubmitting: false,\r\n                isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\r\n                submitCount: formStateRef.current.submitCount + 1,\r\n                errors: formStateRef.current.errors,\r\n            });\r\n        }\r\n    }, [shouldFocusError, isValidateAllFieldCriteria, criteriaMode]);\r\n    const resetFromState = react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](({ keepErrors, keepDirty, keepIsSubmitted, keepTouched, keepIsValid, keepSubmitCount, }) => {\r\n        if (!keepIsValid) {\r\n            validFieldsRef.current = {};\r\n            fieldsWithValidationRef.current = {};\r\n        }\r\n        watchFieldsRef.current = new Set();\r\n        isWatchAllRef.current = false;\r\n        formStateSubjectRef.current.next({\r\n            submitCount: keepSubmitCount ? formStateRef.current.submitCount : 0,\r\n            isDirty: keepDirty ? formStateRef.current.isDirty : false,\r\n            isSubmitted: keepIsSubmitted ? formStateRef.current.isSubmitted : false,\r\n            isValid: keepIsValid\r\n                ? formStateRef.current.isValid\r\n                : !validationMode.isOnSubmit,\r\n            dirtyFields: keepDirty ? formStateRef.current.dirtyFields : {},\r\n            touchedFields: keepTouched ? formStateRef.current.touchedFields : {},\r\n            errors: keepErrors ? formStateRef.current.errors : {},\r\n            isSubmitting: false,\r\n            isSubmitSuccessful: false,\r\n        });\r\n    }, []);\r\n    const reset = (values, keepStateOptions = {}) => {\r\n        const updatedValues = values || defaultValuesRef.current;\r\n        if (isWeb && !keepStateOptions.keepValues) {\r\n            for (const field of Object.values(fieldsRef.current)) {\r\n                if (field && field._f) {\r\n                    const inputRef = Array.isArray(field._f.refs)\r\n                        ? field._f.refs[0]\r\n                        : field._f.ref;\r\n                    if (isHTMLElement(inputRef)) {\r\n                        try {\r\n                            inputRef.closest('form').reset();\r\n                            break;\r\n                        }\r\n                        catch (_a) { }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        !keepStateOptions.keepDefaultValues &&\r\n            (defaultValuesRef.current = Object.assign({}, updatedValues));\r\n        if (!keepStateOptions.keepValues) {\r\n            fieldsRef.current = {};\r\n            controllerSubjectRef.current.next({\r\n                values: Object.assign({}, updatedValues),\r\n            });\r\n            watchSubjectRef.current.next({\r\n                value: Object.assign({}, updatedValues),\r\n            });\r\n            fieldArraySubjectRef.current.next({\r\n                fields: Object.assign({}, updatedValues),\r\n                isReset: true,\r\n            });\r\n        }\r\n        resetFromState(keepStateOptions);\r\n    };\r\n    react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"](() => {\r\n        isMountedRef.current = true;\r\n        const formStateSubscription = formStateSubjectRef.current.subscribe({\r\n            next(formState = {}) {\r\n                if (shouldRenderFormState(formState, readFormStateRef.current, true)) {\r\n                    formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), formState);\r\n                    setFormState(formStateRef.current);\r\n                }\r\n            },\r\n        });\r\n        const useFieldArraySubscription = fieldArraySubjectRef.current.subscribe({\r\n            next(state) {\r\n                if (state.fields && state.name && readFormStateRef.current.isValid) {\r\n                    const values = getFieldsValues(fieldsRef);\r\n                    set(values, state.name, state.fields);\r\n                    updateIsValid(values);\r\n                }\r\n            },\r\n        });\r\n        resolverRef.current && readFormStateRef.current.isValid && updateIsValid();\r\n        return () => {\r\n            watchSubjectRef.current.unsubscribe();\r\n            formStateSubscription.unsubscribe();\r\n            useFieldArraySubscription.unsubscribe();\r\n        };\r\n    }, []);\r\n    return {\r\n        control: react__WEBPACK_IMPORTED_MODULE_0__[\"useMemo\"](() => ({\r\n            register,\r\n            isWatchAllRef,\r\n            watchFieldsRef,\r\n            getFormIsDirty,\r\n            formStateSubjectRef,\r\n            fieldArraySubjectRef,\r\n            controllerSubjectRef,\r\n            watchSubjectRef,\r\n            watchInternal,\r\n            fieldsRef,\r\n            validFieldsRef,\r\n            fieldsWithValidationRef,\r\n            fieldArrayNamesRef,\r\n            readFormStateRef,\r\n            formStateRef,\r\n            defaultValuesRef,\r\n            fieldArrayDefaultValuesRef,\r\n        }), []),\r\n        formState: getProxyFormState(isProxyEnabled, formState, readFormStateRef),\r\n        trigger,\r\n        register,\r\n        handleSubmit,\r\n        watch: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](watch, []),\r\n        setValue: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](setValue, [setInternalValues]),\r\n        getValues: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](getValues, []),\r\n        reset: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](reset, []),\r\n        clearErrors: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](clearErrors, []),\r\n        unregister: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](unregister, []),\r\n        setError: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](setError, []),\r\n    };\r\n}\n\nfunction useWatch(props) {\r\n    const { control, name, defaultValue } = props || {};\r\n    const methods = useFormContext();\r\n    const nameRef = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"](name);\r\n    nameRef.current = name;\r\n    const { watchInternal, watchSubjectRef } = control || methods.control;\r\n    const [value, updateValue] = react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"](isUndefined(defaultValue)\r\n        ? watchInternal(name)\r\n        : defaultValue);\r\n    react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"](() => {\r\n        watchInternal(name);\r\n        const watchSubscription = watchSubjectRef.current.subscribe({\r\n            next: ({ name: inputName, value }) => (!nameRef.current ||\r\n                !inputName ||\r\n                (Array.isArray(nameRef.current)\r\n                    ? nameRef.current\r\n                    : [nameRef.current]).some((fieldName) => inputName &&\r\n                    fieldName &&\r\n                    inputName.startsWith(fieldName))) &&\r\n                updateValue(isString(inputName) &&\r\n                    nameRef.current === inputName &&\r\n                    !isUndefined(value)\r\n                    ? value\r\n                    : watchInternal(nameRef.current, defaultValue)),\r\n        });\r\n        return () => watchSubscription.unsubscribe();\r\n    }, []);\r\n    return value;\r\n}\n\n\n//# sourceMappingURL=index.esm.js.map\n\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["C:\\Users\\evija\\Desktop\\New folder (2)\\KoalaInteriors\\node_modules\\next\\router.js","C:\\Users\\evija\\Desktop\\New folder (2)\\KoalaInteriors\\node_modules\\next\\dist\\build\\webpack\\loaders\\next-babel-loader.js??ref--4!C:\\Users\\evija\\Desktop\\New folder (2)\\KoalaInteriors\\src\\components\\Breadcrumb\\BreadcrumbOne.js","C:\\Users\\evija\\Desktop\\New folder (2)\\KoalaInteriors\\node_modules\\next\\dist\\build\\webpack\\loaders\\next-babel-loader.js??ref--4!C:\\Users\\evija\\Desktop\\New folder (2)\\KoalaInteriors\\src\\components\\Breadcrumb\\ProductListBreadcrumb.js","C:\\Users\\evija\\Desktop\\New folder (2)\\KoalaInteriors\\node_modules\\next\\dist\\build\\webpack\\loaders\\next-babel-loader.js??ref--4!C:\\Users\\evija\\Desktop\\New folder (2)\\KoalaInteriors\\src\\components\\Breadcrumb\\index.js","C:\\Users\\evija\\Desktop\\New folder (2)\\KoalaInteriors\\node_modules\\react-hook-form\\dist\\index.esm.js"],"names":[],"mappings":";;;;;AAAA,iBAAiB,mBAAO,CAAC,MAAsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACArB;AAC1B,YAAY,eAAK;AACqC;;AAEtD,IAAI,2BAAa;AACjB;AACA;AACA;AACA;AACA,GAAG,QAAQ,4BAAS,cAAc,sBAAG;AACrC;AACA,GAAG,QAAQ,sBAAG;AACd;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG,sBAAsB,sBAAG;AAC5B;AACA,GAAG;AACH;;AAEe,wFAAa,E;;ACtBF;AAC1B,IAAI,yBAAK,GAAG,eAAK;AACqC;;AAEtD,IAAI,mCAAa;AACjB;AACA;AACA,SAAS,yBAAK;AACd;AACA,GAAG,EAAE,yBAAK,CAAC,4BAAS,QAAQ,yBAAK,CAAC,sBAAG;AACrC;AACA,GAAG,EAAE,yBAAK,CAAC,sBAAG;AACd;AACA,GAAG,EAAE,yBAAK;AACV;AACA,GAAG,EAAE,yBAAK,uBAAuB,yBAAK;AACtC;AACA,GAAG;AACH;;AAEe,6FAAa,E;;ACpBgB;AACgB;;;;;;;;;ACD5D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+B;;AAE/B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA,oBAAoB,mDAAmB;AACvC;AACA,6BAA6B,gDAAgB;AAC7C,iCAAiC,mDAAmB,wBAAwB,iCAAiC;;AAE7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,sDAAsD;AACjE,yCAAyC,8CAAc;AACvD,0BAA0B,4CAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,+CAAe;AACnB;AACA;AACA;AACA,kEAAkE;AAClE,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA,wBAAwB,sCAAsC;AAC9D;AACA,WAAW,mFAAmF;AAC9F,WAAW,wBAAwB;AACnC,wCAAwC,8CAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI,+CAAe;AACnB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;;AAEA;;AAEA;AACA,oCAAoC,kBAAkB,sCAAsC,+DAA+D,KAAK,0BAA0B,GAAG;;AAE7L;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wDAAwD,YAAY,EAAE,aAAa;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yCAAyC;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,6EAA6E,uDAAuD;;AAEpI;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,oDAAoB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA,iFAAiF;AACjF;AACA;AACA,wDAAwD;AACxD,kDAAkD;AAClD,0EAA0E,wBAAwB,cAAc;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oCAAoC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,iCAAiC;AACzD;AACA,yBAAyB,4CAAY;AACrC,WAAW,mQAAmQ;AAC9Q,gCAAgC,8CAAc;AAC9C;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA,4HAA4H;AAC5H;AACA;AACA;AACA,iBAAiB,KAAK,GAAG,mBAAmB;AAC5C;AACA;AACA;AACA;AACA,yBAAyB,KAAK,GAAG,MAAM;AACvC,aAAa,KAAK,GAAG,MAAM;AAC3B,gIAAgI,KAAK,EAAE,qCAAqC,aAAa,EAAE;AAC3L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iCAAiC,mBAAmB,GAAG,6CAA6C,GAAG,IAAI;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,IAAI,+CAAe;AACnB;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,IAAI,+CAAe;AACnB;AACA,kBAAkB,6CAA6C;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,cAAc,iDAAiB;AAC/B,cAAc,iDAAiB;AAC/B,iBAAiB,iDAAiB;AAClC,gBAAgB,iDAAiB;AACjC,gBAAgB,iDAAiB;AACjC,gBAAgB,iDAAiB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wDAAwD,OAAO;;AAE/D;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,yCAAyC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,WAAW;AACzB,WAAW,QAAQ;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,2HAA2H;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,8CAA8C,oDAAoB;;AAElE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,MAAM,kHAAkH,GAAG;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe;AACf;AACA;AACA,yCAAyC,+FAA+F,QAAQ;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA,yCAAyC;AACzC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mBAAmB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,kHAAkH,0CAA0C,KAAK;AACnL,sBAAsB,4CAAY,GAAG;AACrC,2BAA2B,4CAAY;AACvC,gCAAgC,4CAAY;AAC5C,4BAA4B,4CAAY;AACxC,iCAAiC,4CAAY;AAC7C,iCAAiC,4CAAY;AAC7C,uCAAuC,4CAAY,GAAG;AACtD,2BAA2B,4CAAY;AACvC,yBAAyB,4CAAY;AACrC,oCAAoC,4CAAY,GAAG;AACnD,2BAA2B,4CAAY,GAAG;AAC1C,6BAA6B,4CAAY;AACzC,0BAA0B,4CAAY;AACtC,uBAAuB,4CAAY;AACnC,wBAAwB,4CAAY;AACpC,+BAA+B,4CAAY;AAC3C;AACA;AACA,sCAAsC,8CAAc;AACpD;AACA;AACA,uBAAuB;AACvB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,kBAAkB;AAClB,KAAK;AACL,6BAA6B,4CAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,yBAAyB,4CAAY;AACrC;AACA;AACA;AACA;AACA;AACA,oCAAoC,iDAAiB,+CAA+C;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,WAAW,+FAA+F;AAC7K,iEAAiE;AACjE,2DAA2D;AAC3D;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,0BAA0B,iDAAiB,8BAA8B;AACzE;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,KAAK;AACL,2BAA2B,iDAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mCAAmC,iDAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,8BAA8B,iDAAiB;AAC/C;AACA;AACA;AACA,KAAK;AACL,8CAA8C,iDAAiB;AAC/D,eAAe,SAAS;AACxB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iDAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,8BAA8B,iDAAiB;AAC/C,6BAA6B,KAAK,GAAG,SAAS;AAC9C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,0BAA0B,wBAAwB;AACjH,aAAa;AACb;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA,mEAAmE;AACnE,sCAAsC,cAAc;AACpD;AACA,yBAAyB,iDAAiB,SAAS,wBAAwB,yBAAyB,EAAE;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAkE;AACrF,uEAAuE;AACvE,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,mEAAmE;AACnE;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iDAAiB,mBAAmB;AAC9D;AACA;AACA,mBAAmB,SAAS,2DAA2D;AACvF;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,SAAS;AACT;AACA;AACA,uDAAuD,OAAO,EAAE,UAAU;AAC1E,6EAA6E,WAAW,MAAM;AAC9F;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,iDAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qFAAqF,iDAAiD,IAAI,4BAA4B,6BAA6B,IAAI,wBAAwB;AAC/N;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,cAAc;AAClE;AACA;AACA,iCAAiC,uBAAuB,EAAE,kCAAkC,cAAc,MAAM;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iDAAiB;AACtC;AACA;AACA,4DAA4D;AAC5D,mBAAmB,OAAO,OAAO;AACjC,iCAAiC,4CAA4C,OAAO,uCAAuC,OAAO;AAClI,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,yBAAyB,iDAAiB;AAC1C;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL,2BAA2B,iDAAiB,GAAG,qFAAqF;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E,gFAAgF;AAChF,iEAAiE;AACjE;AACA;AACA,SAAS;AACT,KAAK;AACL,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA,wCAAwC;AACxC,aAAa;AACb;AACA,uCAAuC;AACvC,aAAa;AACb;AACA,wCAAwC;AACxC;AACA,aAAa;AACb;AACA;AACA;AACA,IAAI,+CAAe;AACnB;AACA;AACA,+BAA+B;AAC/B;AACA,yEAAyE;AACzE;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iBAAiB,6CAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,iDAAiB;AAChC,kBAAkB,iDAAiB;AACnC,mBAAmB,iDAAiB;AACpC,eAAe,iDAAiB;AAChC,qBAAqB,iDAAiB;AACtC,oBAAoB,iDAAiB;AACrC,kBAAkB,iDAAiB;AACnC;AACA;;AAEA;AACA,WAAW,8BAA8B;AACzC;AACA,oBAAoB,4CAAY;AAChC;AACA,WAAW,iCAAiC;AAC5C,iCAAiC,8CAAc;AAC/C;AACA;AACA,IAAI,+CAAe;AACnB;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAE2I;AAC3I","file":"x","sourcesContent":["module.exports = require('./dist/client/router')\n","import React from \"react\";\nvar __jsx = React.createElement;\nimport { Container, Row, Col } from \"react-bootstrap\";\n\nvar BreadcrumbOne = function BreadcrumbOne(_ref) {\n  var pageTitle = _ref.pageTitle,\n      children = _ref.children;\n  return __jsx(\"div\", {\n    className: \"breadcrumb-section space-pt--r70\"\n  }, __jsx(Container, null, __jsx(Row, {\n    className: \"align-items-center\"\n  }, __jsx(Col, {\n    md: 6\n  }, __jsx(\"div\", {\n    className: \"page-title\"\n  }, __jsx(\"h3\", {\n    className: \"breadcrumb-title\"\n  }, pageTitle))), __jsx(Col, {\n    md: 6\n  }, children))));\n};\n\nexport default BreadcrumbOne;","import React from \"react\";\nvar __jsx = React.createElement;\nimport { Container, Row, Col } from \"react-bootstrap\";\n\nvar BreadcrumbOne = function BreadcrumbOne(_ref) {\n  var pageTitle = _ref.pageTitle,\n      children = _ref.children;\n  return __jsx(\"div\", {\n    className: \"breadcrumb-section space-pt--r70\"\n  }, __jsx(Container, null, __jsx(Row, {\n    className: \"align-items-center\"\n  }, __jsx(Col, {\n    md: 6\n  }, __jsx(\"div\", {\n    className: \"page-title\"\n  }, __jsx(\"a\", null, children), __jsx(\"h3\", {\n    className: \"breadcrumb-title\"\n  }, pageTitle))))));\n};\n\nexport default BreadcrumbOne;","import BreadcrumbOne from \"./BreadcrumbOne\";\nimport ProductListBreadcrumb from \"./ProductListBreadcrumb\";\nexport { BreadcrumbOne, ProductListBreadcrumb };","import * as React from 'react';\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nvar isNullOrUndefined = (value) => value == null;\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) &&\r\n    !Array.isArray(value) &&\r\n    isObjectType(value) &&\r\n    !(value instanceof Date);\n\nvar getControllerValue = (event) => isObject(event) && event.target\r\n    ? isCheckBoxInput(event.target)\r\n        ? event.target.checked\r\n        : event.target.value\r\n    : event;\n\nvar getNodeParentName = (name) => name.substring(0, name.search(/.\\d/)) || name;\n\nvar isNameInFieldArray = (names, name) => [...names].some((current) => getNodeParentName(name) === current);\n\nvar compact = (value) => value.filter(Boolean);\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj = {}, path, defaultValue) => {\r\n    const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n    return isUndefined(result) || result === obj\r\n        ? isUndefined(obj[path])\r\n            ? defaultValue\r\n            : obj[path]\r\n        : result;\r\n};\n\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n};\r\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n    onTouched: 'onTouched',\r\n    all: 'all',\r\n};\r\nconst SELECT = 'select';\r\nconst UNDEFINED = 'undefined';\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\n\nvar omit = (source, key) => {\r\n    const copy = Object.assign({}, source);\r\n    delete copy[key];\r\n    return copy;\r\n};\n\nconst FormContext = React.createContext(null);\r\nFormContext.displayName = 'RHFContext';\r\nconst useFormContext = () => React.useContext(FormContext);\r\nconst FormProvider = (props) => (React.createElement(FormContext.Provider, { value: omit(props, 'children') }, props.children));\n\nvar getProxyFormState = (isProxyEnabled, formState, readFormStateRef, localReadFormStateRef, isRoot = true) => isProxyEnabled\r\n    ? new Proxy(formState, {\r\n        get: (obj, prop) => {\r\n            if (prop in obj) {\r\n                if (readFormStateRef.current[prop] !== VALIDATION_MODE.all) {\r\n                    readFormStateRef.current[prop] = isRoot\r\n                        ? VALIDATION_MODE.all\r\n                        : true;\r\n                }\r\n                localReadFormStateRef &&\r\n                    (localReadFormStateRef.current[prop] = true);\r\n                return obj[prop];\r\n            }\r\n            return undefined;\r\n        },\r\n    })\r\n    : formState;\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nvar shouldRenderFormState = (formState, readFormStateRef, isRoot) => isEmptyObject(formState) ||\r\n    Object.keys(formState).length >= Object.keys(readFormStateRef).length ||\r\n    Object.keys(formState).find((key) => readFormStateRef[key] ===\r\n        (isRoot ? VALIDATION_MODE.all : true));\n\nvar isWeb = typeof window !== UNDEFINED &&\r\n    typeof window.HTMLElement !== UNDEFINED &&\r\n    typeof document !== UNDEFINED;\n\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nfunction useFormState(props) {\r\n    const methods = useFormContext();\r\n    const { formStateRef, formStateSubjectRef, readFormStateRef } = (props && props.control) || methods.control;\r\n    const [formState, updateFormState] = React.useState(formStateRef.current);\r\n    const readFormState = React.useRef({\r\n        isDirty: false,\r\n        dirtyFields: false,\r\n        touchedFields: false,\r\n        isValidating: false,\r\n        isValid: false,\r\n        errors: false,\r\n    });\r\n    React.useEffect(() => {\r\n        const formStateSubscription = formStateSubjectRef.current.subscribe({\r\n            next: (formState) => {\r\n                shouldRenderFormState(formState, readFormState.current) &&\r\n                    updateFormState(Object.assign(Object.assign({}, formStateRef.current), formState));\r\n            },\r\n        });\r\n        return () => formStateSubscription.unsubscribe();\r\n    }, []);\r\n    return getProxyFormState(isProxyEnabled, formState, readFormStateRef, readFormState, false);\r\n}\n\nfunction useController({ name, rules, defaultValue, control, }) {\r\n    const methods = useFormContext();\r\n    const { defaultValuesRef, register, fieldsRef, fieldArrayNamesRef, controllerSubjectRef, } = control || methods.control;\r\n    const { onChange, onBlur, ref } = register(name, rules);\r\n    const [value, setInputStateValue] = React.useState(isUndefined(get(fieldsRef.current, name)._f.value) ||\r\n        isNameInFieldArray(fieldArrayNamesRef.current, name)\r\n        ? isUndefined(defaultValue)\r\n            ? get(defaultValuesRef.current, name)\r\n            : defaultValue\r\n        : get(fieldsRef.current, name)._f.value);\r\n    const formState = useFormState({\r\n        control: control || methods.control,\r\n    });\r\n    get(fieldsRef.current, name)._f.value = value;\r\n    React.useEffect(() => {\r\n        const controllerSubscription = controllerSubjectRef.current.subscribe({\r\n            next: (data) => (!data.name || name === data.name) &&\r\n                setInputStateValue(get(data.values, name)),\r\n        });\r\n        ref({\r\n            target: value,\r\n        });\r\n        return () => controllerSubscription.unsubscribe();\r\n    }, [name]);\r\n    return {\r\n        field: {\r\n            onChange: (event) => {\r\n                const value = getControllerValue(event);\r\n                setInputStateValue(value);\r\n                onChange({\r\n                    target: {\r\n                        value,\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.CHANGE,\r\n                });\r\n            },\r\n            onBlur: () => {\r\n                onBlur({\r\n                    target: {\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.BLUR,\r\n                });\r\n            },\r\n            name,\r\n            value,\r\n            ref,\r\n        },\r\n        formState,\r\n        fieldState: Object.defineProperties({}, {\r\n            invalid: {\r\n                get() {\r\n                    return !!get(formState.errors, name);\r\n                },\r\n            },\r\n            isDirty: {\r\n                get() {\r\n                    return !!get(formState.dirtyFields, name);\r\n                },\r\n            },\r\n            isTouched: {\r\n                get() {\r\n                    return !!get(formState.touchedFields, name);\r\n                },\r\n            },\r\n            error: {\r\n                get() {\r\n                    return get(formState.errors, name);\r\n                },\r\n            },\r\n        }),\r\n    };\r\n}\n\nconst Controller = (props) => props.render(useController(props));\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria\r\n    ? Object.assign(Object.assign({}, errors[name]), { types: Object.assign(Object.assign({}, (errors[name] && errors[name].types ? errors[name].types : {})), { [type]: message || true }) }) : {};\n\nvar isKey = (value) => /^\\w*$/.test(value);\n\nvar stringToPath = (input) => compact(input.replace(/[\"|']|\\]/g, '').split(/\\.|\\[/));\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || Array.isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nconst focusFieldBy = (fields, callback, fieldsNames) => {\r\n    for (const key of fieldsNames || Object.keys(fields)) {\r\n        const field = get(fields, key);\r\n        if (field) {\r\n            const _f = field._f;\r\n            const current = omit(field, '_f');\r\n            if (_f && callback(_f.name)) {\r\n                if (_f.ref.focus && isUndefined(_f.ref.focus())) {\r\n                    break;\r\n                }\r\n                else if (_f.refs) {\r\n                    _f.refs[0].focus();\r\n                    break;\r\n                }\r\n            }\r\n            else if (isObject(current)) {\r\n                focusFieldBy(current, callback);\r\n            }\r\n        }\r\n    }\r\n};\n\nconst getFieldsValues = (fieldsRef, defaultValuesRef = { current: {} }, output = {}) => {\r\n    for (const name in fieldsRef.current) {\r\n        const field = fieldsRef.current[name];\r\n        if (field) {\r\n            const _f = field._f;\r\n            const current = omit(field, '_f');\r\n            set(output, name, _f\r\n                ? _f.ref.disabled || (_f.refs && _f.refs.every((ref) => ref.disabled))\r\n                    ? undefined\r\n                    : _f.value\r\n                : Array.isArray(field)\r\n                    ? []\r\n                    : {});\r\n            if (current) {\r\n                getFieldsValues({\r\n                    current,\r\n                }, defaultValuesRef, output[name]);\r\n            }\r\n        }\r\n    }\r\n    return Object.assign(Object.assign({}, defaultValuesRef.current), output);\r\n};\n\nvar generateId = () => {\r\n    const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nvar mapIds = (values = [], keyName) => values.map((value) => (Object.assign({ [keyName]: (value && value[keyName]) || generateId() }, value)));\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepEqual(object1, object2, isErrorObject) {\r\n    if (isPrimitive(object1) ||\r\n        isPrimitive(object2) ||\r\n        object1 instanceof Date ||\r\n        object2 instanceof Date) {\r\n        return object1 === object2;\r\n    }\r\n    if (!React.isValidElement(object1)) {\r\n        const keys1 = Object.keys(object1);\r\n        const keys2 = Object.keys(object2);\r\n        if (keys1.length !== keys2.length) {\r\n            return false;\r\n        }\r\n        for (const key of keys1) {\r\n            const val1 = object1[key];\r\n            if (!(isErrorObject && key === 'ref')) {\r\n                const val2 = object2[key];\r\n                if ((isObject(val1) || Array.isArray(val1)) &&\r\n                    (isObject(val2) || Array.isArray(val2))\r\n                    ? !deepEqual(val1, val2, isErrorObject)\r\n                    : val1 !== val2) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n\nfunction deepMerge(target, source) {\r\n    if (isPrimitive(target) || isPrimitive(source)) {\r\n        return source;\r\n    }\r\n    for (const key in source) {\r\n        const targetValue = target[key];\r\n        const sourceValue = source[key];\r\n        try {\r\n            target[key] =\r\n                (isObject(targetValue) && isObject(sourceValue)) ||\r\n                    (Array.isArray(targetValue) && Array.isArray(sourceValue))\r\n                    ? deepMerge(targetValue, sourceValue)\r\n                    : sourceValue;\r\n        }\r\n        catch (_a) { }\r\n    }\r\n    return target;\r\n}\n\nfunction setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\r\n    let index = -1;\r\n    while (++index < values.length) {\r\n        for (const key in values[index]) {\r\n            if (Array.isArray(values[index][key])) {\r\n                !dirtyFields[index] && (dirtyFields[index] = {});\r\n                dirtyFields[index][key] = [];\r\n                setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\r\n            }\r\n            else {\r\n                deepEqual(get(defaultValues[index] || {}, key), values[index][key])\r\n                    ? set(dirtyFields[index] || {}, key)\r\n                    : (dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), { [key]: true }));\r\n            }\r\n        }\r\n        parentNode &&\r\n            !dirtyFields.length &&\r\n            delete parentNode[parentName];\r\n    }\r\n    return dirtyFields;\r\n}\r\nvar setFieldArrayDirtyFields = (values, defaultValues, dirtyFields) => deepMerge(setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)), setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)));\n\nfunction append(data, value) {\r\n    return [...data, ...(Array.isArray(value) ? value : [value])];\r\n}\n\nvar fillEmptyArray = (value) => Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...(Array.isArray(value) ? value : [value]),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar moveArrayAt = (data, from, to) => {\r\n    if (Array.isArray(data)) {\r\n        if (isUndefined(data[to])) {\r\n            data[to] = undefined;\r\n        }\r\n        data.splice(to, 0, data.splice(from, 1)[0]);\r\n        return data;\r\n    }\r\n    return [];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...(Array.isArray(value) ? value : [value]), ...data];\r\n}\n\nfunction removeAtIndexes(data, indexes) {\r\n    let i = 0;\r\n    const temp = [...data];\r\n    for (const index of indexes) {\r\n        temp.splice(index - i, 1);\r\n        i++;\r\n    }\r\n    return compact(temp).length ? temp : [];\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : removeAtIndexes(data, (Array.isArray(index) ? index : [index]).sort((a, b) => a - b));\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    data[indexA] = [data[indexB], (data[indexB] = data[indexA])][0];\r\n};\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\r\n    const length = updatePath.slice(0, -1).length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return object;\r\n}\r\nfunction unset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : stringToPath(path);\r\n    const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    let previousObjRef;\r\n    if (childObject) {\r\n        delete childObject[key];\r\n    }\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index &&\r\n                ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (Array.isArray(objectRef) &&\r\n                        !objectRef.filter((data) => (isObject(data) && !isEmptyObject(data)) || isBoolean(data)).length))) {\r\n                previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return object;\r\n}\n\nconst useFieldArray = ({ control, name, keyName = 'id', }) => {\r\n    const methods = useFormContext();\r\n    const focusNameRef = React.useRef('');\r\n    const { isWatchAllRef, watchFieldsRef, getFormIsDirty, watchSubjectRef, fieldArraySubjectRef, fieldArrayNamesRef, fieldsRef, defaultValuesRef, formStateRef, formStateSubjectRef, readFormStateRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValuesRef, } = control || methods.control;\r\n    const [fields, setFields] = React.useState(mapIds(get(fieldArrayDefaultValuesRef.current, getNodeParentName(name))\r\n        ? get(fieldArrayDefaultValuesRef.current, name, [])\r\n        : get(defaultValuesRef.current, name, []), keyName));\r\n    set(fieldArrayDefaultValuesRef.current, name, [...fields]);\r\n    fieldArrayNamesRef.current.add(name);\r\n    const omitKey = (fields) => fields.map((field) => omit((field || {}), keyName));\r\n    const getCurrentFieldsValues = () => {\r\n        const values = get(getFieldsValues(fieldsRef, defaultValuesRef), name, []);\r\n        return mapIds(get(fieldArrayDefaultValuesRef.current, name, []).map((item, index) => (Object.assign(Object.assign({}, item), values[index]))), keyName);\r\n    };\r\n    const getFocusDetail = (index, options) => options\r\n        ? !isUndefined(options.focusIndex)\r\n            ? `${name}.${options.focusIndex}`\r\n            : options.focusName\r\n                ? options.focusName\r\n                : !options.shouldFocus\r\n                    ? ''\r\n                    : `${name}.${index}`\r\n        : `${name}.${index}`;\r\n    const resetFields = (index) => (Array.isArray(index) ? index : [index]).forEach((currentIndex) => set(fieldsRef.current, `${name}${isUndefined(currentIndex) ? '' : `.${currentIndex}`}`, isUndefined(currentIndex) ? [] : undefined));\r\n    const setFieldsAndNotify = (fieldsValues = []) => setFields(mapIds(fieldsValues, keyName));\r\n    const cleanup = (ref) => !compact(get(ref, name, [])).length && unset(ref, name);\r\n    const updateDirtyFieldsWithDefaultValues = (updatedFieldArrayValues) => updatedFieldArrayValues &&\r\n        set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n    const batchStateUpdate = (method, args, updatedFieldArrayValues = [], shouldSet = true) => {\r\n        if (get(fieldsRef.current, name)) {\r\n            const output = method(get(fieldsRef.current, name), args.argA, args.argB);\r\n            shouldSet && set(fieldsRef.current, name, output);\r\n        }\r\n        if (Array.isArray(get(formStateRef.current.errors, name))) {\r\n            const output = method(get(formStateRef.current.errors, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.errors, name, output);\r\n            cleanup(formStateRef.current.errors);\r\n        }\r\n        if (readFormStateRef.current.touchedFields &&\r\n            get(formStateRef.current.touchedFields, name)) {\r\n            const output = method(get(formStateRef.current.touchedFields, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.touchedFields, name, output);\r\n            cleanup(formStateRef.current.touchedFields);\r\n        }\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n            updateDirtyFieldsWithDefaultValues(updatedFieldArrayValues);\r\n            cleanup(formStateRef.current.dirtyFields);\r\n        }\r\n        if (readFormStateRef.current.isValid) {\r\n            set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));\r\n            cleanup(validFieldsRef.current);\r\n            set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));\r\n            cleanup(fieldsWithValidationRef.current);\r\n        }\r\n        formStateSubjectRef.current.next({\r\n            isDirty: getFormIsDirty(name, omitKey(updatedFieldArrayValues)),\r\n            errors: formStateRef.current.errors,\r\n            isValid: formStateRef.current.isValid,\r\n        });\r\n    };\r\n    const registerFieldArray = (values, index = 0, parentName = '') => values.forEach((appendValueItem, valueIndex) => !isPrimitive(appendValueItem) &&\r\n        Object.entries(appendValueItem).forEach(([key, value]) => {\r\n            const inputName = `${parentName || name}.${parentName ? valueIndex : index + valueIndex}.${key}`;\r\n            Array.isArray(value)\r\n                ? registerFieldArray(value, valueIndex, inputName)\r\n                : set(fieldsRef.current, inputName, {\r\n                    _f: {\r\n                        ref: {\r\n                            name: inputName,\r\n                        },\r\n                        name: inputName,\r\n                        value,\r\n                    },\r\n                });\r\n        }));\r\n    const append$1 = (value, options) => {\r\n        const appendValue = Array.isArray(value) ? value : [value];\r\n        const updatedFieldArrayValues = append(getCurrentFieldsValues(), appendValue);\r\n        const currentIndex = updatedFieldArrayValues.length - appendValue.length;\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(append, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues, false);\r\n        registerFieldArray(appendValue, currentIndex);\r\n        focusNameRef.current = getFocusDetail(currentIndex, options);\r\n    };\r\n    const prepend$1 = (value, options) => {\r\n        const prependValue = Array.isArray(value) ? value : [value];\r\n        const updatedFieldArrayValues = prepend(getCurrentFieldsValues(), prependValue);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(prepend, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues);\r\n        registerFieldArray(prependValue);\r\n        focusNameRef.current = getFocusDetail(0, options);\r\n    };\r\n    const remove = (index) => {\r\n        const updatedFieldArrayValues = removeArrayAt(getCurrentFieldsValues(), index);\r\n        resetFields(index);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(removeArrayAt, {\r\n            argA: index,\r\n        }, updatedFieldArrayValues);\r\n    };\r\n    const insert$1 = (index, value, options) => {\r\n        const insertValue = Array.isArray(value) ? value : [value];\r\n        const updatedFieldArrayValues = insert(getCurrentFieldsValues(), index, insertValue);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(insert, {\r\n            argA: index,\r\n            argB: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues);\r\n        registerFieldArray(insertValue, index);\r\n        focusNameRef.current = getFocusDetail(index, options);\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        swapArrayAt(fieldValues, indexA, indexB);\r\n        batchStateUpdate(swapArrayAt, {\r\n            argA: indexA,\r\n            argB: indexB,\r\n        }, fieldValues, false);\r\n        setFieldsAndNotify(fieldValues);\r\n    };\r\n    const move = (from, to) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        moveArrayAt(fieldValues, from, to);\r\n        setFieldsAndNotify(fieldValues);\r\n        batchStateUpdate(moveArrayAt, {\r\n            argA: from,\r\n            argB: to,\r\n        }, fieldValues, false);\r\n    };\r\n    React.useEffect(() => {\r\n        if (isWatchAllRef.current) {\r\n            formStateSubjectRef.current.next({});\r\n        }\r\n        else {\r\n            for (const watchField of watchFieldsRef.current) {\r\n                if (name.startsWith(watchField)) {\r\n                    formStateSubjectRef.current.next({});\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        watchSubjectRef.current.next({\r\n            name,\r\n            value: get(getFieldsValues(fieldsRef, defaultValuesRef), name, []),\r\n        });\r\n        focusNameRef.current &&\r\n            focusFieldBy(fieldsRef.current, (key) => key.startsWith(focusNameRef.current));\r\n        focusNameRef.current = '';\r\n        fieldArraySubjectRef.current.next({\r\n            name,\r\n            fields: omitKey([...fields]),\r\n        });\r\n    }, [fields, name]);\r\n    React.useEffect(() => {\r\n        const fieldArraySubscription = fieldArraySubjectRef.current.subscribe({\r\n            next({ name: inputFieldArrayName, fields, isReset }) {\r\n                if (isReset) {\r\n                    unset(fieldsRef.current, inputFieldArrayName || name);\r\n                    inputFieldArrayName\r\n                        ? set(fieldArrayDefaultValuesRef.current, inputFieldArrayName, fields)\r\n                        : (fieldArrayDefaultValuesRef.current = fields);\r\n                    setFieldsAndNotify(get(fieldArrayDefaultValuesRef.current, name));\r\n                }\r\n            },\r\n        });\r\n        !get(fieldsRef.current, name) && set(fieldsRef.current, name, []);\r\n        return () => {\r\n            fieldArrayDefaultValuesRef.current = getFieldsValues(fieldsRef);\r\n            fieldArraySubscription.unsubscribe();\r\n        };\r\n    }, []);\r\n    return {\r\n        swap: React.useCallback(swap, [name]),\r\n        move: React.useCallback(move, [name]),\r\n        prepend: React.useCallback(prepend$1, [name]),\r\n        append: React.useCallback(append$1, [name]),\r\n        remove: React.useCallback(remove, [name]),\r\n        insert: React.useCallback(insert$1, [name]),\r\n        fields: fields,\r\n    };\r\n};\n\nfunction getFields(fieldsNames, fieldsRefs) {\r\n    const currentFields = {};\r\n    for (const name of fieldsNames) {\r\n        const field = get(fieldsRefs, name);\r\n        if (field) {\r\n            !isKey(name)\r\n                ? set(currentFields, name, field._f)\r\n                : (currentFields[name] = field._f);\r\n        }\r\n    }\r\n    return currentFields;\r\n}\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isMultipleSelect = (element) => element.type === `${SELECT}-multiple`;\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (Array.isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.checked && !option.disabled)\r\n                .map((option) => option.value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        return options[0].checked && !options[0].disabled\r\n            ? // @ts-expect-error expected to work in the browser\r\n                options[0].attributes && !isUndefined(options[0].attributes.value)\r\n                    ? isUndefined(options[0].value) || options[0].value === ''\r\n                        ? validResult\r\n                        : { value: options[0].value, isValid: true }\r\n                    : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nvar getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => valueAsNumber\r\n    ? value === ''\r\n        ? NaN\r\n        : +value\r\n    : valueAsDate\r\n        ? new Date(value)\r\n        : setValueAs\r\n            ? setValueAs(value)\r\n            : value;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: null,\r\n};\r\nvar getRadioValue = (options) => Array.isArray(options)\r\n    ? options.reduce((previous, option) => option && option.checked && !option.disabled\r\n        ? {\r\n            isValid: true,\r\n            value: option.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nfunction getFieldValue(field) {\r\n    if (field && field._f) {\r\n        const ref = field._f.ref;\r\n        if (ref.disabled) {\r\n            return;\r\n        }\r\n        if (isFileInput(ref)) {\r\n            return ref.files;\r\n        }\r\n        if (isRadioInput(ref)) {\r\n            return getRadioValue(field._f.refs).value;\r\n        }\r\n        if (isMultipleSelect(ref)) {\r\n            return getMultipleSelectValue(ref.options);\r\n        }\r\n        if (isCheckBoxInput(ref)) {\r\n            return getCheckboxValue(field._f.refs).value;\r\n        }\r\n        return getFieldValueAs(isUndefined(ref.value) ? field._f.ref.value : ref.value, field._f);\r\n    }\r\n}\n\nvar skipValidation = ({ isOnBlur, isOnChange, isOnTouch, isTouched, isReValidateOnBlur, isReValidateOnChange, isBlurEvent, isSubmitted, isOnAll, }) => {\r\n    if (isOnAll) {\r\n        return false;\r\n    }\r\n    else if (!isSubmitted && isOnTouch) {\r\n        return !(isTouched || isBlurEvent);\r\n    }\r\n    else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\r\n        return !isBlurEvent;\r\n    }\r\n    else if (isSubmitted ? isReValidateOnChange : isOnChange) {\r\n        return isBlurEvent;\r\n    }\r\n    return true;\r\n};\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isString = (value) => typeof value === 'string';\n\nvar isMessage = (value) => isString(value) || React.isValidElement(value);\n\nvar isRegex = (value) => value instanceof RegExp;\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) || (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData)\r\n    ? validationData\r\n    : {\r\n        value: validationData,\r\n        message: '',\r\n    };\n\nvar validateField = async ({ _f: { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, value: inputValue, valueAsNumber, }, }, validateAllFieldCriteria) => {\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = ((valueAsNumber || isFileInput(ref)) && !ref.value) ||\r\n        inputValue === '' ||\r\n        (Array.isArray(inputValue) && !inputValue.length);\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, appendErrorsCurry(exceedMax ? maxType : minType, message));\r\n    };\r\n    if (required &&\r\n        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(inputValue))) ||\r\n            (isBoolean(inputValue) && !inputValue) ||\r\n            (isCheckBox && !getCheckboxValue(refs).isValid) ||\r\n            (isRadio && !getRadioValue(refs).isValid))) {\r\n        const { value, message } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (value) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message, ref: isRadioOrCheckbox ? (refs || [])[0] || {} : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if ((!isNullOrUndefined(min) || !isNullOrUndefined(max)) &&\r\n        inputValue !== '') {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const maxOutput = getValueAndMessage(max);\r\n        const minOutput = getValueAndMessage(min);\r\n        if (!isNaN(inputValue)) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(inputValue);\r\n            if (!isNullOrUndefined(maxOutput.value)) {\r\n                exceedMax = valueNumber > maxOutput.value;\r\n            }\r\n            if (!isNullOrUndefined(minOutput.value)) {\r\n                exceedMin = valueNumber < minOutput.value;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(inputValue);\r\n            if (isString(maxOutput.value)) {\r\n                exceedMax = valueDate > new Date(maxOutput.value);\r\n            }\r\n            if (isString(minOutput.value)) {\r\n                exceedMin = valueDate < new Date(minOutput.value);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(inputValue) && !isEmpty && (maxLength || minLength)) {\r\n        const maxLengthOutput = getValueAndMessage(maxLength);\r\n        const minLengthOutput = getValueAndMessage(minLength);\r\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&\r\n            inputValue.length > maxLengthOutput.value;\r\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&\r\n            inputValue.length < minLengthOutput.value;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(inputValue) && pattern && !isEmpty) {\r\n        const { value: patternValue, message } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !inputValue.match(patternValue)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message,\r\n                ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        const validateRef = isRadioOrCheckbox && refs ? refs[0] : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(inputValue);\r\n            const validateError = getValidateError(result, validateRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const [key, validateFunction] of Object.entries(validate)) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateResult = await validateFunction(inputValue);\r\n                const validateError = getValidateError(validateResult, validateRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: validateRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return error;\r\n};\n\nvar getValidationModes = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n    isOnAll: mode === VALIDATION_MODE.all,\r\n    isOnTouch: mode === VALIDATION_MODE.onTouched,\r\n});\n\nvar isHTMLElement = (value) => value instanceof HTMLElement;\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nclass Subscription {\r\n    constructor() {\r\n        this.tearDowns = [];\r\n    }\r\n    add(tearDown) {\r\n        this.tearDowns.push(tearDown);\r\n    }\r\n    unsubscribe() {\r\n        for (const teardown of this.tearDowns) {\r\n            teardown();\r\n        }\r\n        this.tearDowns = [];\r\n    }\r\n}\r\nclass Subscriber {\r\n    constructor(observer, subscription) {\r\n        this.observer = observer;\r\n        this.closed = false;\r\n        subscription.add(() => (this.closed = true));\r\n    }\r\n    next(value) {\r\n        if (!this.closed) {\r\n            this.observer.next(value);\r\n        }\r\n    }\r\n}\r\nclass Subject {\r\n    constructor() {\r\n        this.observers = [];\r\n    }\r\n    next(value) {\r\n        for (const observer of this.observers) {\r\n            observer.next(value);\r\n        }\r\n    }\r\n    subscribe(observer) {\r\n        const subscription = new Subscription();\r\n        const subscriber = new Subscriber(observer, subscription);\r\n        this.observers.push(subscriber);\r\n        return subscription;\r\n    }\r\n    unsubscribe() {\r\n        this.observers = [];\r\n    }\r\n}\n\nconst isWindowUndefined = typeof window === UNDEFINED;\r\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, resolver, context, defaultValues = {}, shouldFocusError = true, criteriaMode, } = {}) {\r\n    const fieldsRef = React.useRef({});\r\n    const fieldsNamesRef = React.useRef(new Set());\r\n    const formStateSubjectRef = React.useRef(new Subject());\r\n    const watchSubjectRef = React.useRef(new Subject());\r\n    const controllerSubjectRef = React.useRef(new Subject());\r\n    const fieldArraySubjectRef = React.useRef(new Subject());\r\n    const fieldArrayDefaultValuesRef = React.useRef({});\r\n    const watchFieldsRef = React.useRef(new Set());\r\n    const isMountedRef = React.useRef(false);\r\n    const fieldsWithValidationRef = React.useRef({});\r\n    const validFieldsRef = React.useRef({});\r\n    const defaultValuesRef = React.useRef(defaultValues);\r\n    const isWatchAllRef = React.useRef(false);\r\n    const contextRef = React.useRef(context);\r\n    const resolverRef = React.useRef(resolver);\r\n    const fieldArrayNamesRef = React.useRef(new Set());\r\n    const validationMode = getValidationModes(mode);\r\n    const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\r\n    const [formState, setFormState] = React.useState({\r\n        isDirty: false,\r\n        isValidating: false,\r\n        dirtyFields: {},\r\n        isSubmitted: false,\r\n        submitCount: 0,\r\n        touchedFields: {},\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: !validationMode.isOnSubmit,\r\n        errors: {},\r\n    });\r\n    const readFormStateRef = React.useRef({\r\n        isDirty: !isProxyEnabled,\r\n        dirtyFields: !isProxyEnabled,\r\n        touchedFields: !isProxyEnabled,\r\n        isValidating: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n        errors: !isProxyEnabled,\r\n    });\r\n    const formStateRef = React.useRef(formState);\r\n    contextRef.current = context;\r\n    resolverRef.current = resolver;\r\n    const getIsValid = () => (formStateRef.current.isValid =\r\n        deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\r\n            isEmptyObject(formStateRef.current.errors));\r\n    const shouldRenderBaseOnError = React.useCallback((name, error, shouldRender = false, state = {}, isValid, isWatched) => {\r\n        const previousError = get(formStateRef.current.errors, name);\r\n        let shouldReRender = shouldRender ||\r\n            !deepEqual(previousError, error, true) ||\r\n            (readFormStateRef.current.isValid &&\r\n                isUndefined(error) &&\r\n                get(fieldsWithValidationRef.current, name) &&\r\n                !get(validFieldsRef.current, name));\r\n        if (error) {\r\n            unset(validFieldsRef.current, name);\r\n            shouldReRender =\r\n                shouldReRender ||\r\n                    !previousError ||\r\n                    !deepEqual(previousError, error, true);\r\n            set(formStateRef.current.errors, name, error);\r\n        }\r\n        else {\r\n            if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\r\n                set(validFieldsRef.current, name, true);\r\n                shouldReRender = shouldReRender || previousError;\r\n            }\r\n            unset(formStateRef.current.errors, name);\r\n        }\r\n        if ((shouldReRender && !isNullOrUndefined(shouldRender)) ||\r\n            !isEmptyObject(state) ||\r\n            isWatched) {\r\n            const updatedFormState = Object.assign(Object.assign({}, state), { isValid: resolverRef.current ? !!isValid : getIsValid(), errors: formStateRef.current.errors });\r\n            formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), updatedFormState);\r\n            formStateSubjectRef.current.next(isWatched ? {} : updatedFormState);\r\n        }\r\n        formStateSubjectRef.current.next({\r\n            isValidating: false,\r\n        });\r\n    }, []);\r\n    const setFieldValue = React.useCallback((name, rawValue, options = {}, shouldRender, shouldRegister) => {\r\n        shouldRegister && register(name);\r\n        const _f = get(fieldsRef.current, name, {})._f;\r\n        if (_f) {\r\n            const value = isWeb && isHTMLElement(_f.ref) && isNullOrUndefined(rawValue)\r\n                ? ''\r\n                : rawValue;\r\n            _f.value = rawValue;\r\n            if (isRadioInput(_f.ref)) {\r\n                (_f.refs || []).forEach((radioRef) => (radioRef.checked = radioRef.value === value));\r\n            }\r\n            else if (isFileInput(_f.ref) && !isString(value)) {\r\n                _f.ref.files = value;\r\n            }\r\n            else if (isMultipleSelect(_f.ref)) {\r\n                [..._f.ref.options].forEach((selectRef) => (selectRef.selected = value.includes(selectRef.value)));\r\n            }\r\n            else if (isCheckBoxInput(_f.ref) && _f.refs) {\r\n                _f.refs.length > 1\r\n                    ? _f.refs.forEach((checkboxRef) => (checkboxRef.checked = Array.isArray(value)\r\n                        ? !!value.find((data) => data === checkboxRef.value)\r\n                        : value === checkboxRef.value))\r\n                    : (_f.refs[0].checked = !!value);\r\n            }\r\n            else {\r\n                _f.ref.value = value;\r\n            }\r\n            if (shouldRender) {\r\n                const values = getFieldsValues(fieldsRef);\r\n                set(values, name, rawValue);\r\n                controllerSubjectRef.current.next({\r\n                    values: Object.assign(Object.assign({}, defaultValuesRef.current), values),\r\n                    name,\r\n                });\r\n            }\r\n            options.shouldDirty && updateAndGetDirtyState(name, value);\r\n            options.shouldValidate && trigger(name);\r\n        }\r\n    }, []);\r\n    const getFormIsDirty = React.useCallback((name, data) => {\r\n        if (readFormStateRef.current.isDirty) {\r\n            const formValues = getFieldsValues(fieldsRef);\r\n            name && data && set(formValues, name, data);\r\n            return !deepEqual(formValues, defaultValuesRef.current);\r\n        }\r\n        return false;\r\n    }, []);\r\n    const updateAndGetDirtyState = React.useCallback((name, inputValue, shouldRender = true) => {\r\n        if (readFormStateRef.current.isDirty ||\r\n            readFormStateRef.current.dirtyFields) {\r\n            const isFieldDirty = !deepEqual(get(defaultValuesRef.current, name), inputValue);\r\n            const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\r\n            const previousIsDirty = formStateRef.current.isDirty;\r\n            isFieldDirty\r\n                ? set(formStateRef.current.dirtyFields, name, true)\r\n                : unset(formStateRef.current.dirtyFields, name);\r\n            formStateRef.current.isDirty = getFormIsDirty();\r\n            const state = {\r\n                isDirty: formStateRef.current.isDirty,\r\n                dirtyFields: formStateRef.current.dirtyFields,\r\n            };\r\n            const isChanged = (readFormStateRef.current.isDirty &&\r\n                previousIsDirty !== state.isDirty) ||\r\n                (readFormStateRef.current.dirtyFields &&\r\n                    isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\r\n            isChanged && shouldRender && formStateSubjectRef.current.next(state);\r\n            return isChanged ? state : {};\r\n        }\r\n        return {};\r\n    }, []);\r\n    const executeValidation = React.useCallback(async (name, skipReRender) => {\r\n        const error = (await validateField(get(fieldsRef.current, name), isValidateAllFieldCriteria))[name];\r\n        shouldRenderBaseOnError(name, error, skipReRender);\r\n        return isUndefined(error);\r\n    }, [isValidateAllFieldCriteria]);\r\n    const executeSchemaOrResolverValidation = React.useCallback(async (names, currentNames = []) => {\r\n        const { errors } = await resolverRef.current(getFieldsValues(fieldsRef, defaultValuesRef), contextRef.current, {\r\n            criteriaMode,\r\n            names: currentNames,\r\n            fields: getFields(fieldsNamesRef.current, fieldsRef.current),\r\n        });\r\n        for (const name of names) {\r\n            const error = get(errors, name);\r\n            error\r\n                ? set(formStateRef.current.errors, name, error)\r\n                : unset(formStateRef.current.errors, name);\r\n        }\r\n        return errors;\r\n    }, [criteriaMode]);\r\n    const validateForm = async (fieldsRef) => {\r\n        for (const name in fieldsRef) {\r\n            const field = fieldsRef[name];\r\n            if (field) {\r\n                const _f = field._f;\r\n                const current = omit(field, '_f');\r\n                if (_f) {\r\n                    const fieldError = await validateField(field, isValidateAllFieldCriteria);\r\n                    if (fieldError[_f.name]) {\r\n                        set(formStateRef.current.errors, _f.name, fieldError[_f.name]);\r\n                        unset(validFieldsRef.current, _f.name);\r\n                    }\r\n                    else if (get(fieldsWithValidationRef.current, _f.name)) {\r\n                        set(validFieldsRef.current, _f.name, true);\r\n                        unset(formStateRef.current.errors, _f.name);\r\n                    }\r\n                }\r\n                current && (await validateForm(current));\r\n            }\r\n        }\r\n    };\r\n    const trigger = React.useCallback(async (name) => {\r\n        const fields = isUndefined(name)\r\n            ? Object.keys(fieldsRef.current)\r\n            : Array.isArray(name)\r\n                ? name\r\n                : [name];\r\n        let isValid;\r\n        formStateSubjectRef.current.next({\r\n            isValidating: true,\r\n        });\r\n        if (resolverRef.current) {\r\n            isValid = isEmptyObject(await executeSchemaOrResolverValidation(fields, isUndefined(name)\r\n                ? undefined\r\n                : fields));\r\n        }\r\n        else {\r\n            isUndefined(name)\r\n                ? await validateForm(fieldsRef.current)\r\n                : await Promise.all(fields.map(async (data) => await executeValidation(data, null)));\r\n        }\r\n        formStateSubjectRef.current.next({\r\n            errors: formStateRef.current.errors,\r\n            isValidating: false,\r\n            isValid: resolverRef.current ? isValid : getIsValid(),\r\n        });\r\n    }, [executeSchemaOrResolverValidation, executeValidation]);\r\n    const setInternalValues = React.useCallback((name, value, options) => Object.entries(value).forEach(([inputKey, inputValue]) => {\r\n        const fieldName = `${name}.${inputKey}`;\r\n        const field = get(fieldsRef.current, fieldName);\r\n        field && !field._f\r\n            ? setInternalValues(fieldName, inputValue, options)\r\n            : setFieldValue(fieldName, inputValue, options, true, !field);\r\n    }), [trigger]);\r\n    const isFieldWatched = (name) => isWatchAllRef.current ||\r\n        watchFieldsRef.current.has(name) ||\r\n        watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\r\n    const updateValidAndValue = (name, options, isWithinRefCallback) => {\r\n        let defaultValue;\r\n        const field = get(fieldsRef.current, name);\r\n        const useFormDefaultValue = get(defaultValuesRef.current, name);\r\n        if (field &&\r\n            (!isEmptyObject(defaultValuesRef.current) || !isUndefined(field._f.value))) {\r\n            defaultValue = isUndefined(field._f.value)\r\n                ? useFormDefaultValue\r\n                : field._f.value;\r\n            if (!isNullOrUndefined(defaultValue)) {\r\n                setFieldValue(name, defaultValue);\r\n            }\r\n        }\r\n        if ((useFormDefaultValue || (!useFormDefaultValue && isWithinRefCallback)) &&\r\n            options &&\r\n            !validationMode.isOnSubmit &&\r\n            field &&\r\n            readFormStateRef.current.isValid) {\r\n            validateField(field, isValidateAllFieldCriteria).then((error) => {\r\n                isEmptyObject(error)\r\n                    ? set(validFieldsRef.current, name, true)\r\n                    : unset(validFieldsRef.current, name);\r\n                formStateRef.current.isValid &&\r\n                    !isEmptyObject(error) &&\r\n                    setFormState(Object.assign(Object.assign({}, formStateRef.current), { isValid: getIsValid() }));\r\n            });\r\n        }\r\n        return defaultValue;\r\n    };\r\n    const setValue = (name, value, options = {}) => {\r\n        isMountedRef.current = true;\r\n        const field = get(fieldsRef.current, name);\r\n        const isFieldArray = fieldArrayNamesRef.current.has(name);\r\n        if (isFieldArray) {\r\n            fieldArraySubjectRef.current.next({\r\n                fields: value,\r\n                name,\r\n                isReset: true,\r\n            });\r\n            if ((readFormStateRef.current.isDirty ||\r\n                readFormStateRef.current.dirtyFields) &&\r\n                options.shouldDirty) {\r\n                set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n                formStateSubjectRef.current.next({\r\n                    dirtyFields: formStateRef.current.dirtyFields,\r\n                    isDirty: getFormIsDirty(name, value),\r\n                });\r\n            }\r\n            !value.length &&\r\n                set(fieldsRef.current, name, []) &&\r\n                set(fieldArrayDefaultValuesRef.current, name, []);\r\n        }\r\n        (field && !field._f) || isFieldArray\r\n            ? setInternalValues(name, value, isFieldArray ? {} : options)\r\n            : setFieldValue(name, value, options, true, !field);\r\n        isFieldWatched(name) && formStateSubjectRef.current.next({});\r\n        watchSubjectRef.current.next({ name, value });\r\n    };\r\n    const handleChange = React.useCallback(async ({ type, target, target: { value, type: inputType } }) => {\r\n        let name = target.name;\r\n        let error;\r\n        let isValid;\r\n        const field = get(fieldsRef.current, name);\r\n        if (field) {\r\n            let inputValue = inputType ? getFieldValue(field) : undefined;\r\n            inputValue = isUndefined(inputValue) ? value : inputValue;\r\n            const isBlurEvent = type === EVENTS.BLUR;\r\n            const { isOnBlur: isReValidateOnBlur, isOnChange: isReValidateOnChange, } = getValidationModes(reValidateMode);\r\n            const shouldSkipValidation = skipValidation(Object.assign({ isBlurEvent, isTouched: !!get(formStateRef.current.touchedFields, name), isSubmitted: formStateRef.current.isSubmitted, isReValidateOnBlur,\r\n                isReValidateOnChange }, validationMode));\r\n            const isWatched = !isBlurEvent && isFieldWatched(name);\r\n            if (!isUndefined(inputValue)) {\r\n                field._f.value = inputValue;\r\n            }\r\n            const state = updateAndGetDirtyState(name, field._f.value, false);\r\n            if (isBlurEvent && !get(formStateRef.current.touchedFields, name)) {\r\n                set(formStateRef.current.touchedFields, name, true);\r\n                readFormStateRef.current.touchedFields &&\r\n                    (state.touchedFields = formStateRef.current.touchedFields);\r\n            }\r\n            let shouldRender = !isEmptyObject(state) || isWatched;\r\n            if (shouldSkipValidation) {\r\n                !isBlurEvent &&\r\n                    watchSubjectRef.current.next({\r\n                        name,\r\n                        type,\r\n                        value: inputValue,\r\n                    });\r\n                return (shouldRender &&\r\n                    formStateSubjectRef.current.next(isWatched ? {} : state));\r\n            }\r\n            formStateSubjectRef.current.next({\r\n                isValidating: true,\r\n            });\r\n            if (resolverRef.current) {\r\n                const { errors } = await resolverRef.current(getFieldsValues(fieldsRef, defaultValuesRef), contextRef.current, {\r\n                    criteriaMode,\r\n                    fields: getFields([name], fieldsRef.current),\r\n                    names: [name],\r\n                });\r\n                const previousFormIsValid = formStateRef.current.isValid;\r\n                error = get(errors, name);\r\n                if (isCheckBoxInput(target) && !error) {\r\n                    const parentNodeName = getNodeParentName(name);\r\n                    const currentError = get(errors, parentNodeName, {});\r\n                    currentError.type && currentError.message && (error = currentError);\r\n                    if (currentError ||\r\n                        get(formStateRef.current.errors, parentNodeName)) {\r\n                        name = parentNodeName;\r\n                    }\r\n                }\r\n                isValid = isEmptyObject(errors);\r\n                previousFormIsValid !== isValid && (shouldRender = true);\r\n            }\r\n            else {\r\n                error = (await validateField(field, isValidateAllFieldCriteria))[name];\r\n            }\r\n            !isBlurEvent &&\r\n                watchSubjectRef.current.next({\r\n                    name,\r\n                    type,\r\n                    value: inputValue,\r\n                });\r\n            shouldRenderBaseOnError(name, error, shouldRender, state, isValid, isWatched);\r\n        }\r\n    }, []);\r\n    const getValues = (fieldNames) => {\r\n        const values = isMountedRef.current\r\n            ? getFieldsValues(fieldsRef, defaultValuesRef)\r\n            : defaultValuesRef.current;\r\n        return isUndefined(fieldNames)\r\n            ? values\r\n            : isString(fieldNames)\r\n                ? get(values, fieldNames)\r\n                : fieldNames.map((name) => get(values, name));\r\n    };\r\n    const updateIsValid = React.useCallback(async (values = {}) => {\r\n        const previousIsValid = formStateRef.current.isValid;\r\n        if (resolver) {\r\n            const { errors } = await resolverRef.current(Object.assign(Object.assign({}, getFieldsValues(fieldsRef, defaultValuesRef)), values), contextRef.current, {\r\n                criteriaMode,\r\n                fields: getFields(fieldsNamesRef.current, fieldsRef.current),\r\n            });\r\n            formStateRef.current.isValid = isEmptyObject(errors);\r\n        }\r\n        else {\r\n            getIsValid();\r\n        }\r\n        previousIsValid !== formStateRef.current.isValid &&\r\n            formStateSubjectRef.current.next({\r\n                isValid: formStateRef.current.isValid,\r\n            });\r\n    }, [criteriaMode]);\r\n    const clearErrors = (name) => {\r\n        name &&\r\n            (Array.isArray(name) ? name : [name]).forEach((inputName) => unset(formStateRef.current.errors, inputName));\r\n        formStateSubjectRef.current.next({\r\n            errors: name ? formStateRef.current.errors : {},\r\n        });\r\n    };\r\n    const setError = (name, error, options) => {\r\n        const ref = ((get(fieldsRef.current, name) || { _f: {} })._f || {}).ref;\r\n        set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), { ref }));\r\n        formStateSubjectRef.current.next({\r\n            errors: formStateRef.current.errors,\r\n            isValid: false,\r\n        });\r\n        options && options.shouldFocus && ref && ref.focus && ref.focus();\r\n    };\r\n    const watchInternal = React.useCallback((fieldNames, defaultValue, isGlobal) => {\r\n        const isArrayNames = Array.isArray(fieldNames);\r\n        const fieldValues = isMountedRef.current\r\n            ? getValues()\r\n            : isUndefined(defaultValue)\r\n                ? defaultValuesRef.current\r\n                : isArrayNames\r\n                    ? defaultValue || {}\r\n                    : { [fieldNames]: defaultValue };\r\n        if (isUndefined(fieldNames)) {\r\n            isGlobal && (isWatchAllRef.current = true);\r\n            return fieldValues;\r\n        }\r\n        const result = [];\r\n        for (const fieldName of isArrayNames ? fieldNames : [fieldNames]) {\r\n            isGlobal && watchFieldsRef.current.add(fieldName);\r\n            result.push(get(fieldValues, fieldName));\r\n        }\r\n        return isArrayNames ? result : result[0];\r\n    }, []);\r\n    const watch = (fieldName, defaultValue) => isFunction(fieldName)\r\n        ? watchSubjectRef.current.subscribe({\r\n            next: (info) => fieldName(watchInternal(undefined, defaultValue), info),\r\n        })\r\n        : watchInternal(fieldName, defaultValue, true);\r\n    const unregister = (name, options = {}) => {\r\n        for (const inputName of name\r\n            ? Array.isArray(name)\r\n                ? name\r\n                : [name]\r\n            : Object.keys(fieldsNamesRef.current)) {\r\n            fieldsNamesRef.current.delete(inputName);\r\n            fieldArrayNamesRef.current.delete(inputName);\r\n            if (get(fieldsRef.current, inputName)) {\r\n                if (!options.keepIsValid) {\r\n                    unset(fieldsWithValidationRef.current, inputName);\r\n                    unset(validFieldsRef.current, inputName);\r\n                }\r\n                !options.keepError && unset(formStateRef.current.errors, inputName);\r\n                !options.keepValue && unset(fieldsRef.current, inputName);\r\n                !options.keepDirty &&\r\n                    unset(formStateRef.current.dirtyFields, inputName);\r\n                !options.keepTouched &&\r\n                    unset(formStateRef.current.touchedFields, inputName);\r\n                !options.keepDefaultValue && unset(defaultValuesRef.current, inputName);\r\n                watchSubjectRef.current.next({\r\n                    name: inputName,\r\n                });\r\n            }\r\n        }\r\n        formStateSubjectRef.current.next(Object.assign(Object.assign(Object.assign({}, formStateRef.current), (!options.keepDirty ? {} : { isDirty: getFormIsDirty() })), (resolverRef.current ? {} : { isValid: getIsValid() })));\r\n        if (!options.keepIsValid) {\r\n            updateIsValid();\r\n        }\r\n    };\r\n    const registerFieldRef = (name, ref, options) => {\r\n        let field = get(fieldsRef.current, name);\r\n        if (field) {\r\n            const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n            if (ref === field._f.ref ||\r\n                (isWeb && isHTMLElement(field._f.ref) && !isHTMLElement(ref)) ||\r\n                (isRadioOrCheckbox &&\r\n                    Array.isArray(field._f.refs) &&\r\n                    compact(field._f.refs).find((option) => option === ref))) {\r\n                return;\r\n            }\r\n            field = {\r\n                _f: isRadioOrCheckbox\r\n                    ? Object.assign(Object.assign({}, field._f), { refs: [\r\n                            ...compact(field._f.refs || []).filter((ref) => isHTMLElement(ref) && document.contains(ref)),\r\n                            ref,\r\n                        ], ref: { type: ref.type, name } }) : Object.assign(Object.assign({}, field._f), { ref }),\r\n            };\r\n            set(fieldsRef.current, name, field);\r\n            const defaultValue = updateValidAndValue(name, options, true);\r\n            if (isRadioOrCheckbox && Array.isArray(defaultValue)\r\n                ? !deepEqual(get(fieldsRef.current, name)._f.value, defaultValue)\r\n                : isUndefined(get(fieldsRef.current, name)._f.value)) {\r\n                get(fieldsRef.current, name)._f.value = getFieldValue(get(fieldsRef.current, name));\r\n            }\r\n        }\r\n    };\r\n    const register = React.useCallback((name, options) => {\r\n        const isInitialRegister = !get(fieldsRef.current, name);\r\n        set(fieldsRef.current, name, {\r\n            _f: Object.assign(Object.assign(Object.assign({}, (isInitialRegister\r\n                ? { ref: { name } }\r\n                : Object.assign({ ref: (get(fieldsRef.current, name)._f || {}).ref }, get(fieldsRef.current, name)._f))), { name }), options),\r\n        });\r\n        options && set(fieldsWithValidationRef.current, name, true);\r\n        fieldsNamesRef.current.add(name);\r\n        isInitialRegister && updateValidAndValue(name, options);\r\n        return isWindowUndefined\r\n            ? { name: name }\r\n            : {\r\n                name,\r\n                onChange: handleChange,\r\n                onBlur: handleChange,\r\n                ref: (ref) => ref && registerFieldRef(name, ref, options),\r\n            };\r\n    }, [defaultValuesRef.current]);\r\n    const handleSubmit = React.useCallback((onValid, onInvalid) => async (e) => {\r\n        if (e && e.preventDefault) {\r\n            e.preventDefault();\r\n            e.persist();\r\n        }\r\n        let fieldValues = Object.assign(Object.assign({}, defaultValuesRef.current), getFieldsValues(fieldsRef, defaultValuesRef));\r\n        formStateSubjectRef.current.next({\r\n            isSubmitting: true,\r\n        });\r\n        try {\r\n            if (resolverRef.current) {\r\n                const { errors, values } = await resolverRef.current(fieldValues, contextRef.current, {\r\n                    criteriaMode,\r\n                    fields: getFields(fieldsNamesRef.current, fieldsRef.current),\r\n                });\r\n                formStateRef.current.errors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                await validateForm(fieldsRef.current);\r\n            }\r\n            if (isEmptyObject(formStateRef.current.errors) &&\r\n                Object.keys(formStateRef.current.errors).every((name) => get(fieldValues, name))) {\r\n                formStateSubjectRef.current.next({\r\n                    errors: {},\r\n                    isSubmitting: true,\r\n                });\r\n                await onValid(fieldValues, e);\r\n            }\r\n            else {\r\n                onInvalid && (await onInvalid(formStateRef.current.errors, e));\r\n                shouldFocusError &&\r\n                    focusFieldBy(fieldsRef.current, (key) => get(formStateRef.current.errors, key), fieldsNamesRef.current);\r\n            }\r\n        }\r\n        finally {\r\n            formStateRef.current.isSubmitted = true;\r\n            formStateSubjectRef.current.next({\r\n                isSubmitted: true,\r\n                isSubmitting: false,\r\n                isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\r\n                submitCount: formStateRef.current.submitCount + 1,\r\n                errors: formStateRef.current.errors,\r\n            });\r\n        }\r\n    }, [shouldFocusError, isValidateAllFieldCriteria, criteriaMode]);\r\n    const resetFromState = React.useCallback(({ keepErrors, keepDirty, keepIsSubmitted, keepTouched, keepIsValid, keepSubmitCount, }) => {\r\n        if (!keepIsValid) {\r\n            validFieldsRef.current = {};\r\n            fieldsWithValidationRef.current = {};\r\n        }\r\n        watchFieldsRef.current = new Set();\r\n        isWatchAllRef.current = false;\r\n        formStateSubjectRef.current.next({\r\n            submitCount: keepSubmitCount ? formStateRef.current.submitCount : 0,\r\n            isDirty: keepDirty ? formStateRef.current.isDirty : false,\r\n            isSubmitted: keepIsSubmitted ? formStateRef.current.isSubmitted : false,\r\n            isValid: keepIsValid\r\n                ? formStateRef.current.isValid\r\n                : !validationMode.isOnSubmit,\r\n            dirtyFields: keepDirty ? formStateRef.current.dirtyFields : {},\r\n            touchedFields: keepTouched ? formStateRef.current.touchedFields : {},\r\n            errors: keepErrors ? formStateRef.current.errors : {},\r\n            isSubmitting: false,\r\n            isSubmitSuccessful: false,\r\n        });\r\n    }, []);\r\n    const reset = (values, keepStateOptions = {}) => {\r\n        const updatedValues = values || defaultValuesRef.current;\r\n        if (isWeb && !keepStateOptions.keepValues) {\r\n            for (const field of Object.values(fieldsRef.current)) {\r\n                if (field && field._f) {\r\n                    const inputRef = Array.isArray(field._f.refs)\r\n                        ? field._f.refs[0]\r\n                        : field._f.ref;\r\n                    if (isHTMLElement(inputRef)) {\r\n                        try {\r\n                            inputRef.closest('form').reset();\r\n                            break;\r\n                        }\r\n                        catch (_a) { }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        !keepStateOptions.keepDefaultValues &&\r\n            (defaultValuesRef.current = Object.assign({}, updatedValues));\r\n        if (!keepStateOptions.keepValues) {\r\n            fieldsRef.current = {};\r\n            controllerSubjectRef.current.next({\r\n                values: Object.assign({}, updatedValues),\r\n            });\r\n            watchSubjectRef.current.next({\r\n                value: Object.assign({}, updatedValues),\r\n            });\r\n            fieldArraySubjectRef.current.next({\r\n                fields: Object.assign({}, updatedValues),\r\n                isReset: true,\r\n            });\r\n        }\r\n        resetFromState(keepStateOptions);\r\n    };\r\n    React.useEffect(() => {\r\n        isMountedRef.current = true;\r\n        const formStateSubscription = formStateSubjectRef.current.subscribe({\r\n            next(formState = {}) {\r\n                if (shouldRenderFormState(formState, readFormStateRef.current, true)) {\r\n                    formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), formState);\r\n                    setFormState(formStateRef.current);\r\n                }\r\n            },\r\n        });\r\n        const useFieldArraySubscription = fieldArraySubjectRef.current.subscribe({\r\n            next(state) {\r\n                if (state.fields && state.name && readFormStateRef.current.isValid) {\r\n                    const values = getFieldsValues(fieldsRef);\r\n                    set(values, state.name, state.fields);\r\n                    updateIsValid(values);\r\n                }\r\n            },\r\n        });\r\n        resolverRef.current && readFormStateRef.current.isValid && updateIsValid();\r\n        return () => {\r\n            watchSubjectRef.current.unsubscribe();\r\n            formStateSubscription.unsubscribe();\r\n            useFieldArraySubscription.unsubscribe();\r\n        };\r\n    }, []);\r\n    return {\r\n        control: React.useMemo(() => ({\r\n            register,\r\n            isWatchAllRef,\r\n            watchFieldsRef,\r\n            getFormIsDirty,\r\n            formStateSubjectRef,\r\n            fieldArraySubjectRef,\r\n            controllerSubjectRef,\r\n            watchSubjectRef,\r\n            watchInternal,\r\n            fieldsRef,\r\n            validFieldsRef,\r\n            fieldsWithValidationRef,\r\n            fieldArrayNamesRef,\r\n            readFormStateRef,\r\n            formStateRef,\r\n            defaultValuesRef,\r\n            fieldArrayDefaultValuesRef,\r\n        }), []),\r\n        formState: getProxyFormState(isProxyEnabled, formState, readFormStateRef),\r\n        trigger,\r\n        register,\r\n        handleSubmit,\r\n        watch: React.useCallback(watch, []),\r\n        setValue: React.useCallback(setValue, [setInternalValues]),\r\n        getValues: React.useCallback(getValues, []),\r\n        reset: React.useCallback(reset, []),\r\n        clearErrors: React.useCallback(clearErrors, []),\r\n        unregister: React.useCallback(unregister, []),\r\n        setError: React.useCallback(setError, []),\r\n    };\r\n}\n\nfunction useWatch(props) {\r\n    const { control, name, defaultValue } = props || {};\r\n    const methods = useFormContext();\r\n    const nameRef = React.useRef(name);\r\n    nameRef.current = name;\r\n    const { watchInternal, watchSubjectRef } = control || methods.control;\r\n    const [value, updateValue] = React.useState(isUndefined(defaultValue)\r\n        ? watchInternal(name)\r\n        : defaultValue);\r\n    React.useEffect(() => {\r\n        watchInternal(name);\r\n        const watchSubscription = watchSubjectRef.current.subscribe({\r\n            next: ({ name: inputName, value }) => (!nameRef.current ||\r\n                !inputName ||\r\n                (Array.isArray(nameRef.current)\r\n                    ? nameRef.current\r\n                    : [nameRef.current]).some((fieldName) => inputName &&\r\n                    fieldName &&\r\n                    inputName.startsWith(fieldName))) &&\r\n                updateValue(isString(inputName) &&\r\n                    nameRef.current === inputName &&\r\n                    !isUndefined(value)\r\n                    ? value\r\n                    : watchInternal(nameRef.current, defaultValue)),\r\n        });\r\n        return () => watchSubscription.unsubscribe();\r\n    }, []);\r\n    return value;\r\n}\n\nexport { Controller, FormProvider, appendErrors, get, set, useController, useFieldArray, useForm, useFormContext, useFormState, useWatch };\n//# sourceMappingURL=index.esm.js.map\n"]}}